# Tips & Tricks {#integration}

This section is providing hints (some may call it hacks) to substitute classical preprocessors like Intel fpp or GNU cpp with fpx. 
These pieces of information are extracted from different sources and collected here for convenience. May this be useful to anyone willing to try.
[TOC]
## fpp

<!-- - [fpp-name](https://www.intel.com/content/www/us/en/docs/fortran-compiler/developer-guide-reference/2023-0/fpp-name.html)
- [Qlocation](https://www.intel.com/content/www/us/en/docs/fortran-compiler/developer-guide-reference/2023-0/qlocation.html#GUID-DF120360-7780-415F-ACF2-15A23D727801)
- [forum](https://community.intel.com/t5/Intel-Fortran-Compiler/Undocumented-behavior-of-fpp-with-alternative-preprocessor/td-p/1411981) -->

### fpp-name

The [fpp-name](https://www.intel.com/content/www/us/en/docs/fortran-compiler/developer-guide-reference/2023-0/fpp-name.html) Lets you specify an alternate preprocessor to use with Fortran.

**Syntax**
|  |  |
|:--|--:|
|Linux|-fpp-name=name|
|macOS|-fpp-name=name|
|Windows|/fpp-name:name|

**Arguments**
    name
Is the name of the preprocessor executable. It can include a path. See the description below for more details.

**Default**
    OFF
No preprocessor is run on files before compilation.

**Description**
This option lets you specify an alternate preprocessor to use with Fortran.


The compiler invokes the user-specified Fortran preprocessor by spawning a command with the following signature:
```bash
alt_fpp @fpp.arg 
```
where alt_fpp is the name of the Fortran preprocessor you want to use, and fpp.arg is an input file containing the preprocessor's command line arguments.

fpp.arg is generated by the Fortran compiler driver, and contains the -D<define>, -I<include directory>, and input file names from the compiler command line. Compiler predefined options -D<define> and -I<include directory> are also included. Output from the preprocessor goes to STDOUT and will be captured for any further processing.

You can use option Qoption,fpp,… to pass other definitions (using -D<define>), include directories (using -I<include directory>), or other options accepted by the preprocessor.

You can use option Qlocation, fpp,… to specify a directory for supporting tools.

### Known issues

- [link](https://github.com/aradi/fypp/issues/24)

> The Intel compilers provide a flag `-fpp-name=<name>` which can be used to specify an alternative preprocessor of the form:
>
> alt_fpp [ [–D<define>]..] [[-I<include directory>]..] inputfile 
> which prints output to STDOUT that will get captured by the compiler for further processing.
>
> I've tried to use this with fypp, but I run into errors:
> ```
> $ ifx -fpp-name=`which fypp` -DNAME=\"Ivan\" fypp_example.F90 
> error: Failed to open file '@/tmp/ifxargBf8BjW' for read [FyppFatalError]
> error: [Errno 2] No such file or directory: '@/tmp/ifxargBf8BjW' [FileNotFoundError]
> ```
> ```
> $ ifx -fpp-name=fypp -Qlocation,fpp,/home/ivan/.local/bin -DNAME=\"Ivan\" fypp_example.F90 
> error: Failed to open file '@/tmp/ifxarg6DL4Me' for read [FyppFatalError]
> error: [Errno 2] No such file or directory: '@/tmp/ifxarg6DL4Me' [FileNotFoundError]
> ```
> It seems like the compiler prepends @ to the path, but otherwise it seems it could work. If you'd like to experiment, here is the toy code:
> ```
> ! fypp_example.F90
> #:def hello(name)
> print *, "Hello ${name}$"
> #:enddef
>
> #:if defined('NAME')
> $:hello(NAME)
> #:else
> print *, "Hello World"
> #:endif
> end
> ```

## cpp

This answer from Jim Dempsey is taken from the [intel forum](https://community.intel.com/t5/Intel-Fortran-Compiler/ifort-preprocessor-and-variadic-macros/td-p/832383) 
> You could experiment with shell piping gcc preprocessor in front of (or in place of) fpp.
> 
> In your development environment, insert in PATH, in front of other paths, a path to a GCChack folder containing a copy of the GCC preprocessor renamed to FPP.EXE. This assumes the GCC preprocessor can completely preprocess the source. This can also be a shell `program > youwrite` that handles the shell call to GCC then to FPP.
>
> **Plan B** is to create a batch file that first runs the GCC preprocessor, then runs the FPP preprocessor. Place the batch file into the "hack" folder under the name "FPP.EXE". Windows will (has for me) examine the contents of the start of the file and determine it is a batch file.
>
> **Plan C** is to create pre-build events and actions to pre-pre-process the files using the GCC pre-processor.