<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="dark-mode">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.12.0"/>
  <title>fpx.f: Preprocessor Specifications (24-142r2)</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeFragmentCopyButton.init()
      DoxygenAwesomeDarkModeToggle.init()
      DoxygenAwesomeParagraphLink.init()
      DoxygenAwesomeInteractiveToc.init()
      DoxygenAwesomeTabs.init()
  </script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script>
$(function() {
	hljs.configure({useBR: false});
	$(".fragment").each(function(i,node) {
		$(node).removeClass("fragment");
		hljs.highlightBlock(node);
	});
});
</script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectlogo"><img alt="Logo" src="logo.png" /></td>
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">fpx.f</a>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('specifications.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Preprocessor Specifications (24-142r2)</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#autotoc_md32">1 Introduction</a>
  </li>
  <li class="level1">
    <a href="#autotoc_md33">2 Lexical specifications</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md34">2.1 Lines</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md35">2.2 Case sensitivity of identifiers</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md36">2.3 Significance of whitespace</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md37">2.4 Comments</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md38">2.5 Token lexicon</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md39">3 #-Directives</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md40">3.1 The #define object-like macro directive</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md41">3.1.1 Static semantics specifications</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md42">3.1.2 Evaluation semantics specifications</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#autotoc_md43">3.2 The #define function-like macro directive</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md44">3.2.1 Static semantics specifications</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md45">3.2.2 Evaluation semantics specifications</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#autotoc_md46">3.3 The #undef directive</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md47">3.3.1 Static semantics specifications</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md48">3.3.2 Evaluation semantics specifications</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#autotoc_md49">3.4 The #include directive</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md50">3.4.1 Static semantics specifications</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md51">3.4.2 Evaluation semantics specifications</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#autotoc_md52">3.5 The #if, #ifdef, #ifndef, #elif, #elifdef, #elifndef, #else, #endif conditional directives</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md53">3.5.1 Static semantics specifications</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md54">3.5.2 Evaluation semantics specifications</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#autotoc_md55">3.6 The #error and #warning directives</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md56">3.6.1 Static semantics specifications</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md57">3.6.2 Evaluation semantics specifications</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#autotoc_md58">3.7 The #line directive</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md59">3.7.1 Static semantics specifications</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md60">3.7.2 Evaluation semantics specifications</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#autotoc_md61">3.8 The #pragma directive</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md62">3.8.1 Static semantics specifications</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md63">3.8.2 Evaluation semantics specifications</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#autotoc_md64">3.9 The null directive</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md65">3.9.1 Static semantics specifications</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md66">3.9.2 Evaluation semantics specifications</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#autotoc_md67">3.10 The processor-dependent directive</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md68">3.10.1 Static semantics specifications</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md69">3.10.2 Evaluation semantics specifications</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md70">4 Macro identification and expansion</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md71">4.1 Comparison to macro identification and expansion in CPP</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md72">4.2 The identifiers __VA_ARGS__ and __VA_OPT__</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md73">4.3 The # and ## operators</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md74">5 Expressions allowed in #if and #elif directives</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md75">5.1 Operators allowed in controlling expressions</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md76">7 Predefined macros</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md77">7.1 __LINE__</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md78">7.2 __FILE__</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md79">7.3 __DATE__</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md80">7.4 __TIME__</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md81">7.5 __STDF__</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md82">8 INCLUDE line processing</a>
  </li>
  <li class="level1">
    <a href="#autotoc_md83">9 Translation limits</a>
  </li>
  <li class="level1">
    <a href="#autotoc_md84">Appendix A: Divergences from C</a>
  </li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md__c_1_2_users_2_david_pfister_2_git_hub_2sandbox_2fpx_8f_2_8dox_2articles_2j3_225-142r2"></a></p>
<h1><a class="anchor" id="autotoc_md32"></a>
1 Introduction</h1>
<p>At its meeting Feb 19, 2025, J3 decided to approve requirements for a cpp-like preprocessor for Fortran 202Y (paper 25-114r2).</p>
<p>This is the formal specifications document, revised according to the discussion arising from 25-114r2.</p>
<p>Terminology: For the purpose of this specification, the "preprocessor" encompasses all stages of preprocessing of the input text. For didactic purposes, that might include additional phases of "preprocessing" that help define the expected priorities of preprocessing behaviors. (In past discussions, these have included line continuation processing, comment handling, and tokenization for the preprocessor.)</p>
<h1><a class="anchor" id="autotoc_md33"></a>
2 Lexical specifications</h1>
<h2><a class="anchor" id="autotoc_md34"></a>
2.1 Lines</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">li00   </td><td class="markdownTableBodyLeft">The Fortran preprocessor recognizes three distinct types of lines: preprocessing directives (and continuation lines thereof), Fortran comment lines, and Fortran source fragments.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">li11   </td><td class="markdownTableBodyLeft">A line that has a <code>#</code> character as the first non-blank character of the line is a directive line (as required by C 2023 section 6.10.1 paragraph 2), except when otherwise specified by the next two rules.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">li13   </td><td class="markdownTableBodyLeft">In fixed source form, a <code>#</code> in column 6 of a non-comment line does not introduce a directive line.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">li15   </td><td class="markdownTableBodyLeft">A preprocessor directive can be continued with a backslash <code>\</code> immediately followed by a new-line. The backslash and new-line are deleted, the content of the subsequent line is textually appended to the current directive, and the subsequent line is deleted. This process repeats until the current directive does not end with a backslash <code>\</code> immediately followed by a new-line.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">li17   </td><td class="markdownTableBodyLeft">Preprocessor directive continuation processing described by the prior rule is effectively performed before any other processing of the text in affected lines.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">li19   </td><td class="markdownTableBodyLeft">The maximum length of a preprocessor directive (including continuation text) is one million characters.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">li21   </td><td class="markdownTableBodyLeft">A source file that ends with a directive line shall neither end with a <code>\</code>, nor a <code>\</code> followed immediately by a new-line (analogously to C 2023 section 5.1.1.2 bullet 2).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">li31   </td><td class="markdownTableBodyLeft">Fortran comment lines are defined as in 25-007 6.3.2.3 and 6.3.3.2.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">li41   </td><td class="markdownTableBodyLeft">Fortran source fragments are those lines that are neither preprocessor directive lines (or continuations thereof) nor Fortran comment lines.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">li43   </td><td class="markdownTableBodyLeft">Text on fixed-form Fortran source fragments is ignored beyond column 72.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">li45   </td><td class="markdownTableBodyLeft">Fortran source fragments may be continued with a continuation (<code>&amp;</code> at the end of a free-form line as specified in Fortran 2023 6.3.2.4, or with a non-blank, non-zero character in column 6 of a fixed-form line as specified in Fortran 2023 6.3.3.3).   </td></tr>
</table>
<p><b>Example 1 (free-form)</b>:</p>
<div class="fragment"><div class="line">    <span class="keyword">call </span>subroutine_foo(1, 2, &amp;</div>
<div class="line"><span class="preprocessor">#ifdef USE_3</span></div>
<div class="line"><span class="preprocessor"></span>                            3, &amp;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>                            666, &amp;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>                            .true.)</div>
</div><!-- fragment --><p><b>Example 2 (fixed-form)</b>:</p>
<div class="fragment"><div class="line">    <span class="keyword">call </span>subroutine_foo(1, 2,</div>
<div class="line"><span class="preprocessor">#ifdef USE_3</span></div>
<div class="line"><span class="preprocessor"></span>    1                       3,</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>    1                       666,</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    2                       .true.)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md35"></a>
2.2 Case sensitivity of identifiers</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">cs01   </td><td class="markdownTableBodyLeft">Directive names are case-sensitive and recognized in lower-case.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">cs03   </td><td class="markdownTableBodyLeft">Macro names and function-like macro argument names are case-sensitive.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">cs05   </td><td class="markdownTableBodyLeft">Predefined macro names are case-sensitive.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md36"></a>
2.3 Significance of whitespace</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ws01   </td><td class="markdownTableBodyLeft">The whitespace characters blank and horizontal tab character may appear on directive lines.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ws02   </td><td class="markdownTableBodyLeft">Whitespace may appear before or after the '#' character that introduces a directive line.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ws03   </td><td class="markdownTableBodyLeft">Whitespace characters are significant in determining token boundaries in preprocessor directive lines.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ws05   </td><td class="markdownTableBodyLeft">Outside of character constants, multiple whitespace characters on a directive line are treated as a single space.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ws07   </td><td class="markdownTableBodyLeft">Whitespace characters are significant in determining token boundaries for the purposes of recognizing macro names, in both fixed-form and free-form Fortran source fragments.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ws09   </td><td class="markdownTableBodyLeft">Whitespace characters are significant in determining token boundaries for the purposes of recognizing macro names, in both fixed-form and free-form Fortran comment lines.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ws11   </td><td class="markdownTableBodyLeft">In fixed-form input, macro names are not recognized as such when spaces are inserted into their invocations.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md37"></a>
2.4 Comments</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">co01   </td><td class="markdownTableBodyLeft">Directive lines may contain C-style <code>/*</code> ... <code>*/</code> comments    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">co05   </td><td class="markdownTableBodyLeft"><code>/*</code> ... <code>*/</code> comments on directive lines shall extend past a new-line only if the line ends in <code>\</code> new-line, indicating a continuation line.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">co07   </td><td class="markdownTableBodyLeft"><code>/*</code> ... <code>*/</code> comments on directive lines are replaced by a single space, as specified in C 2023 section 5.1.1.2 bullet 3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">co08   </td><td class="markdownTableBodyLeft">In a directive line, the <code>//</code> token is not interpreted as introducing a C-style comment, and neither the <code>//</code> token nor any subsequent text are removed by the preprocessor.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">co09   </td><td class="markdownTableBodyLeft">In a directive line, the <code>!</code> character is not interpreted as introducing a Fortran-style comment, and neither the <code>!</code> character nor any subsequent text are removed by the preprocessor.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">co11   </td><td class="markdownTableBodyLeft">Directive lines (by definition) cannot contain Fortran fixed-form <code>C</code> or <code>*</code> style comments.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md38"></a>
2.5 Token lexicon</h2>
<p>The preprocessor decomposes the source file into preprocessing tokens (see C 2023 section 5.1.1.2 Translation phases).</p>
<p>As such, there is a specific lexicon of tokens recognized by the preprocessor (including unrecognizable tokens).</p>
<p>As in C 2023, these tokens are recognized after any line and comment handling specified in section 2.1 "Lines" and section 2.4 "Comments" above.</p>
<p>We use illustrative syntax to describe the directive specifications, and the translation behavior of the preprocess on Fortran comment lines and Fortran source fragment lines.</p>
<p>This illustrative syntax makes use of these "tokens".</p>
<p>Further definition of the recognized tokens is deferred to the upcoming preprocessor syntax paper.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">to01   </td><td class="markdownTableBodyLeft">In the definitions of object macros and function-like macros, the replacement list may include any arbitrary sequence of characters that doesn't include a new-line. Once tokenized, this for example may include any tokens allowed in Fortran source fragments, those allowed in C integer expressions, and any additional tokens recognized by the processor.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">to03   </td><td class="markdownTableBodyLeft">Without naming all the tokens explicitly, they appear in the illustrative syntax in subsequent sections.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">to09   </td><td class="markdownTableBodyLeft">The preprocessor is line-oriented. To define the end of a logical line (after continuation handling), the 'EOL' token is shown explicitly in the illustrative syntax.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">to11   </td><td class="markdownTableBodyLeft">The following tokens also appear in the illustrative syntax below.   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Token name   </th><th class="markdownTableHeadLeft">Characters    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ID   </td><td class="markdownTableBodyLeft">Regex <code>[A-Za-z_][A-Za-z0-9_]*</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">WHOLE_NUMBER   </td><td class="markdownTableBodyLeft">Regex <code>[0-9]+</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">CHARACTER_STRING   </td><td class="markdownTableBodyLeft">Regex <code>[^"<br  />
]*</code> where <code>\n</code> represents new-line.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">EOL   </td><td class="markdownTableBodyLeft">The new-line ending a directive line, after continuation processing (see li15).   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md39"></a>
3 #-Directives</h1>
<p>The following directives are recognized during Fortran preprocessing. Detailed specifications for each directive appear in the subsections below.</p>
<p>We use illustrative syntax in the detailed descriptions. Detailed syntax will appear in a paper to be named later.</p>
<p>Most directives take a sequence of tokens (as defined in section 2.5 "Token lexicon" above). In the detailed descriptions and illustrative syntax below, we denote these as just "token-list" or "replacement-list".</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">di00   </td><td class="markdownTableBodyLeft">The directives listed in di01-di08 are only recognized as such if the token immediately following the <code>#</code> introducing a directive line exactly matches one of the standard directive names (<code>define</code>, <code>if</code>, <code>pragma</code>, etc.).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">di01   </td><td class="markdownTableBodyLeft">The <code>#define</code> object-like macro directive    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">di02   </td><td class="markdownTableBodyLeft">The <code>#define</code> function-like macro directive    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">di03   </td><td class="markdownTableBodyLeft">The <code>#undef</code> directive    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">di04   </td><td class="markdownTableBodyLeft">The <code>#include</code> directive    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">di05   </td><td class="markdownTableBodyLeft">The <code>#if</code>, <code>#ifdef</code>, <code>#ifndef</code>, <code>#elif</code>, <code>#elifdef</code>, <code>#elifndef</code>, <code>#else</code>, <code>#endif</code> conditional directives    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">di06   </td><td class="markdownTableBodyLeft">The <code>#error</code> and <code>#warning</code> directives    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">di07   </td><td class="markdownTableBodyLeft">The <code>#line</code> directive    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">di08   </td><td class="markdownTableBodyLeft">The <code>#pragma</code> directive    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">di09   </td><td class="markdownTableBodyLeft">The <code>null</code> directive    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">di10   </td><td class="markdownTableBodyLeft">The processor-dependent directive   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md40"></a>
3.1 The define object-like macro directive</h2>
<p>See also the rules for expanding object-like macros in section 4 "Macro identification and expansion" below.</p>
<p>Example syntax: </p><div class="fragment"><div class="line"><span class="preprocessor">#define ID replacement-list EOL</span></div>
<div class="line"><span class="preprocessor"></span>...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md41"></a>
3.1.1 Static semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">do02   </td><td class="markdownTableBodyLeft">The replacement-list is a (possibly empty) sequence of tokens.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">do04   </td><td class="markdownTableBodyLeft">The identifier ID must be immediately followed by whitespace or EOL.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">do06   </td><td class="markdownTableBodyLeft">Whitespace before or after the replacement-list is not considered to be part of the replacement-list.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md42"></a>
3.1.2 Evaluation semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">do20   </td><td class="markdownTableBodyLeft">This <code>#define</code> directive defines an object-like macro named by ID with a replacement list comprised of the tokens specified in the replacement-list.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">do22   </td><td class="markdownTableBodyLeft">There is one name space for all macro names.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">do24   </td><td class="markdownTableBodyLeft">The <code>#define</code> directive does not scan the replacement-list for macros to expand.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">do26   </td><td class="markdownTableBodyLeft">An identifier currently defined as an object-like macro shall not be redefined by another <code>#define</code> preprocessing directive unless the second definition is an object-like macro definition and the two replacement lists are identical (as in C 2023).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">do28   </td><td class="markdownTableBodyLeft">Two replacement lists are identical if and only if the preprocessing tokens in both have the same number, ordering, spelling, and white-space separation, where all white-space separations are considered identical (as in C 2023).   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md43"></a>
3.2 The define function-like macro directive</h2>
<p>See also the rules for expanding function-like macros in the section 4 "Macro identification and expansion" below.</p>
<p>Example syntax: </p><div class="fragment"><div class="line"><span class="preprocessor">#define ID() replacement-list EOL</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define ID(identifier-list) replacement-list EOL</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define ID(...) replacement-list EOL</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define ID(identifier-list, ...) replacement-list EOL</span></div>
<div class="line"><span class="preprocessor"></span>...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md44"></a>
3.2.1 Static semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">df02   </td><td class="markdownTableBodyLeft">The identifier ID must be immediately followed by a left parenthesis <code>(</code> with no intervening whitespace.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">df04   </td><td class="markdownTableBodyLeft">The identifier-list is a comma-separated list of ID tokens.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">df06   </td><td class="markdownTableBodyLeft">No identifier may appear more than once in the identifier-list.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">df08   </td><td class="markdownTableBodyLeft">The identifier names in the identifier-list define macro "parameters" that affect macro expansion of the replacement list. (See section 4 "Macro identification and expansion" for the semantics of function-like macro expansion.)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">df10   </td><td class="markdownTableBodyLeft">The replacement-list may be the empty sequence of tokens.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">df12   </td><td class="markdownTableBodyLeft">Whitespace before or after the replacement-list is not considered to be part of the replacement-list.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">df16   </td><td class="markdownTableBodyLeft">The '...' between the parentheses specifies that the function-like macro may be invoked with a variable number of arguments. (See section 4 "Macro identification and expansion" for the semantics of function-like macros with a variable number of arguments.)   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md45"></a>
3.2.2 Evaluation semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">df30   </td><td class="markdownTableBodyLeft">This <code>#define</code> directive defines a function-like macro named by ID with the specified macro parameters and with a replacement list comprised of the tokens specified in the replacement-list.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">df32   </td><td class="markdownTableBodyLeft">This <code>#define</code> directive does not scan the replacement-list for macros to expand.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">df34   </td><td class="markdownTableBodyLeft">An identifier currently defined as a function-like macro shall not be redefined by another <code>#define</code> preprocessing directive unless the second definition is a function-like macro definition, with the same number and spelling of the parameters, and the two replacement lists are identical (as in C 2023).   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md46"></a>
3.3 The undef directive</h2>
<p>Example syntax: </p><div class="fragment"><div class="line"><span class="preprocessor">#undef ID EOL</span></div>
<div class="line"><span class="preprocessor"></span>...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md47"></a>
3.3.1 Static semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ud02   </td><td class="markdownTableBodyLeft">ID shall not be one of the macros defined in section 7 "Predefined macros" below.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ud04   </td><td class="markdownTableBodyLeft">The specified identifier may or may not have been defined.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md48"></a>
3.3.2 Evaluation semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ud20   </td><td class="markdownTableBodyLeft">If no definition exists for the identifier ID, this directive has no effect.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ud22   </td><td class="markdownTableBodyLeft">The definition for the object-like macro or function-like macro named by ID is removed.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md49"></a>
3.4 The include directive</h2>
<p>Example syntax: </p><div class="fragment"><div class="line"><span class="preprocessor">#include CHARACTER_STRING EOL</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;character-list&gt; EOL</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include token-list EOL</span></div>
<div class="line"><span class="preprocessor"></span>...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md50"></a>
3.4.1 Static semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">in06   </td><td class="markdownTableBodyLeft">In the second form, the character-list is any sequence of processor-dependent characters except EOL and '&gt;'.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">in08   </td><td class="markdownTableBodyLeft">In the third form, the token-list does not match the previous two forms.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md51"></a>
3.4.2 Evaluation semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">in18   </td><td class="markdownTableBodyLeft">In the third form, the token-list is processed as in Fortran source fragments (see section 4 "Macro identification and expansion" below). The directive resulting after all replacements shall match one of the previous two forms, and evaluation proceeds as such.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">in20   </td><td class="markdownTableBodyLeft">The preprocessor searches in processor-defined places for the file denoted by the CHARACTER_STRING or the character-list.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">in22   </td><td class="markdownTableBodyLeft">It is an error if the processor cannot locate the specified file.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">in24   </td><td class="markdownTableBodyLeft">If the file is located, the processor replaces the <code>#include</code> directive line with the contents of that file.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">in26   </td><td class="markdownTableBodyLeft">A <code>#include</code> directive may appear in an included file, up to a processor-defined nesting limit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">in28   </td><td class="markdownTableBodyLeft">Unlike INCLUDE lines in Fortran 2023 (see 25-007 section 6.4, "Including source text"), the <code>#include</code> directive is not prohibited from including the same source file at a deeper level of nesting. See also section 8 "INCLUDE line processing".   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md52"></a>
3.5 The if, ifdef, ifndef, elif, elifdef, elifndef, else, endif conditional directives</h2>
<p>Example syntax (extra spacing for illustration purposes only):</p>
<div class="fragment"><div class="line">General form:</div>
<div class="line">      &lt;if-head&gt;  &lt;if-elif-list&gt;             #endif EOL</div>
<div class="line">      &lt;if-head&gt;  &lt;if-elif-list&gt;  &lt;if-else&gt;  #endif EOL</div>
<div class="line"> </div>
<div class="line">Where:</div>
<div class="line">      &lt;if-head&gt; is one of:</div>
<div class="line">      #if token-list EOL  &lt;group&gt;</div>
<div class="line">      #ifdef ID EOL       &lt;group&gt;</div>
<div class="line">      #ifndef ID EOL      &lt;group&gt;</div>
<div class="line"> </div>
<div class="line">      &lt;if-elif-list&gt; is zero or more of:</div>
<div class="line">      &lt;if-elif&gt;</div>
<div class="line"> </div>
<div class="line">      &lt;if-elif&gt; is one of:</div>
<div class="line">      #elif     token-list EOL  &lt;group&gt;</div>
<div class="line">      #elifdef  ID EOL          &lt;group&gt;</div>
<div class="line">      #elifndef ID EOL          &lt;group&gt;</div>
<div class="line"> </div>
<div class="line">      &lt;if-else&gt; is one of:</div>
<div class="line">      #else EOL  &lt;group&gt;</div>
<div class="line"> </div>
<div class="line">      &lt;group&gt; is zero or more of:</div>
<div class="line">      directive lines</div>
<div class="line">      Fortran comment lines</div>
<div class="line">      Fortran source fragment lines</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md53"></a>
3.5.1 Static semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">if05   </td><td class="markdownTableBodyLeft">An <code>&lt;if-head&gt;</code> is comprised of a <code>#if</code>, <code>#ifdef</code>, or <code>#ifndef</code> directive and signals the start of a "chain" of conditional directives.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">if15   </td><td class="markdownTableBodyLeft">A series of <code>#elif</code>, <code>#elifdef</code>, and <code>#elifndef</code> directives, and the else directive (if present) are part of the same chain of directives introduced by the nearest preceding <code>&lt;if-head&gt;</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">if20   </td><td class="markdownTableBodyLeft">A chain of conditional directives ends with the <code>#endif</code> directive.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">if25   </td><td class="markdownTableBodyLeft">Within a conditional directive chain, a <code>#if</code>, <code>#ifdef</code>, or <code>#ifndef</code> directive introduces a new chain of conditional directives, at a new nesting level, within the enclosing conditional directive chain.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">if30   </td><td class="markdownTableBodyLeft">The conditional directive chains must properly nest, with each nested chain appearing entirely within a single <code>&lt;group&gt;</code> of the enclosing chain.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md54"></a>
3.5.2 Evaluation semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ix05   </td><td class="markdownTableBodyLeft">The <code>#ifdef</code> and <code>#ifndef</code> directives are evaluated as if they had been written <code>#if defined(ID)</code> and <code>#if !defined(ID)</code> respectively. (For brevity, the descriptions of <code>#ifdef</code> and <code>#ifndef</code> directives below are omitted, and assume this transformation.)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ix10   </td><td class="markdownTableBodyLeft">The <code>#elifdef</code> and <code>#elifndef</code> directives are evaluated as if they had been written <code>#elif defined(ID)</code> and <code>#elif !defined(ID)</code> respectively. (For brevity, the descriptions below assume this transformation has been made).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ix12   </td><td class="markdownTableBodyLeft">In the descriptions below, constructs may be "skipped". When skipped:<ul>
<li>
Conditional directives within the construct are recognized only to maintain proper nesting of conditional directives.</li>
<li>
No nested directives in the construct are processed.</li>
<li>
No macro expansion takes place in directive lines, Fortran comment lines or Fortran source fragment lines in the construct.</li>
<li>
No skipped lines of any kind in the construct are made available to subsequent processing by the processor.</li>
</ul>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ix14   </td><td class="markdownTableBodyLeft">In the descriptions below, <code>&lt;group&gt;</code> constructs that are not skipped participate in further preprocessing and processing. When participating:<ul>
<li>
Macros are expanded in Fortran comment lines and Fortran source fragment lines.</li>
<li>
Nested directives in the &lt;group&gt; are processed.</li>
<li>
The resulting Fortran comment lines and Fortran source fragment lines are made available for subsequent processing by the processor.</li>
</ul>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ix15   </td><td class="markdownTableBodyLeft">Before evaluating the token-lists in any <code>&lt;if-head&gt;</code> and <code>&lt;if-elif&gt;</code> constructs that are not skipped, macros in the token-lists are processed as described in section 4 "Macro identification and expansion".    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ix20   </td><td class="markdownTableBodyLeft">After expansion, the resulting token list in <code>&lt;if-head&gt;</code> and <code>&lt;if-elif&gt;</code> constructs that are not skipped must comprise a valid integer expression as described in section 5 "Expressions allowed in `#if` and `#elif` directives" static semantics. This expression is called the "controlling expression" for the directive.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ix25   </td><td class="markdownTableBodyLeft">The values of controlling expressions in <code>&lt;if-head&gt;</code> and <code>&lt;if-elif&gt;</code> constructs are evaluated according to the evaluation semantics described in section 5 "Expressions allowed in `#if` and `#elif` directives".    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ix30   </td><td class="markdownTableBodyLeft">If the controlling expression in an <code>&lt;if-head&gt;</code> evaluates to a nonzero value, then the <code>&lt;group&gt;</code> contained within that <code>&lt;if-head&gt;</code> construct participates in further preprocessing, as described above. Subsequent <code>&lt;if-elif&gt;</code> and <code>&lt;if-else&gt;</code> constructs in the same chain are skipped.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ix45   </td><td class="markdownTableBodyLeft">If the controlling expression in an &lt;if-head&gt; construct evaluates to a zero value, then the <code>&lt;group&gt;</code> contained within that <code>&lt;if-head&gt;</code> construct is skipped. Preprocessing continues with any <code>&lt;if-elif&gt;</code> constructs in the same chain, as described below.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ix50   </td><td class="markdownTableBodyLeft">When the controlling expression in an <code>&lt;if-head&gt;</code> construct evaluates to zero, the controlling expressions in each <code>&lt;if-elif&gt;</code> construct in the same chain are evaluated in turn, until one evaluates to a non-zero value. Those &lt;group&gt;s whose controlling expression evaluates to zero are skipped.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ix55   </td><td class="markdownTableBodyLeft">When the controlling expression in an <code>&lt;if-elif&gt;</code> construct evaluates to a nonzero value, the <code>&lt;group&gt;</code> contained within that <code>&lt;if-elif&gt;</code> construct continues to participate in preprocessing. Subsequent <code>&lt;if-elif&gt;</code> constructs and any remaining <code>&lt;if-else&gt;</code> constructs in the same chain are skipped.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ix60   </td><td class="markdownTableBodyLeft">When all controlling expressions in the <code>&lt;if-head&gt;</code> construct and <code>&lt;if-elif&gt;</code> constructs evaluate to a zero value and an <code>&lt;if-else&gt;</code> construct is present in the same chain, the <code>&lt;group&gt;</code> contained in the <code>&lt;if-else&gt;</code> construct continues to participate in preprocessing.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ix65   </td><td class="markdownTableBodyLeft">When all controlling expressions in the <code>&lt;if-head&gt;</code> construct and all <code>&lt;if-elif&gt;</code> constructs evaluate to a zero value and no <code>&lt;if-else&gt;</code> construct is present in the same chain, then all &lt;group&gt;s in these constructs are skipped.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md55"></a>
3.6 The error and warning directives</h2>
<p>Example syntax: </p><div class="fragment"><div class="line"><span class="preprocessor">#error token-list EOL</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#warning token-list EOL</span></div>
<div class="line"><span class="preprocessor"></span>...</div>
</div><!-- fragment --><p>The <code>#error</code> and <code>#warning</code> directives are used to announce user-defined error conditions in the input.</p>
<h3><a class="anchor" id="autotoc_md56"></a>
3.6.1 Static semantics specifications</h3>
<h3><a class="anchor" id="autotoc_md57"></a>
3.6.2 Evaluation semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ew02   </td><td class="markdownTableBodyLeft">The token-list is not expanded.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ew04   </td><td class="markdownTableBodyLeft">The processor produces a diagnostic message that includes the token-list.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ew06   </td><td class="markdownTableBodyLeft">The processor shall reject a submitted program if the processor encounters a <code>#error</code> directive during preprocessing.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ew10   </td><td class="markdownTableBodyLeft">Additional behavior is processor-dependent.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md58"></a>
3.7 The line directive</h2>
<p>Example syntax: </p><div class="fragment"><div class="line"><span class="preprocessor">#line WHOLE_NUMBER EOL</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#line WHOLE_NUMBER CHARACTER_STRING EOL</span></div>
<div class="line"><span class="preprocessor"></span>...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md59"></a>
3.7.1 Static semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">li02   </td><td class="markdownTableBodyLeft">The WHOLE_NUMBER shall not be zero.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">li04   </td><td class="markdownTableBodyLeft">The WHOLE_NUMBER shall not exceed 2147483647.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md60"></a>
3.7.2 Evaluation semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">li20   </td><td class="markdownTableBodyLeft">In both forms, the line directive causes the processor to behave as if the following sequence of lines begins with a presumed line number specified by the WHOLE_NUMBER.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">li24   </td><td class="markdownTableBodyLeft">In the second form, the line directive causes the processor to change the presumed file name of the source file to be the contents of the CHARACTER_STRING.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md61"></a>
3.8 The pragma directive</h2>
<p>Example syntax: </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma token-list EOL</span></div>
<div class="line"><span class="preprocessor"></span>...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md62"></a>
3.8.1 Static semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">pr02   </td><td class="markdownTableBodyLeft">The token-list may not be empty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">pr10   </td><td class="markdownTableBodyLeft">The token-list shall not begin with the identifier 'STDF', either before or after macro expansion.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md63"></a>
3.8.2 Evaluation semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">pr20   </td><td class="markdownTableBodyLeft">The semantics of the token-list are processor-dependent. In particular, it is processor-dependent whether macro expansion is performed on the token-list.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">pr22   </td><td class="markdownTableBodyLeft">The <code>#pragma</code> directive causes the processor to behave in a processor-defined manner.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">pr24   </td><td class="markdownTableBodyLeft">Any <code>#pragma</code> that is not recognized by the processor is ignored.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md64"></a>
3.9 The null directive</h2>
<p>Example syntax: </p><div class="fragment"><div class="line"><span class="preprocessor"># EOL</span></div>
<div class="line"><span class="preprocessor"></span>...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md65"></a>
3.9.1 Static semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">nu02   </td><td class="markdownTableBodyLeft">The only tokens allowed on a null directive are the <code>#</code> and the end-of-line indicator EOL.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md66"></a>
3.9.2 Evaluation semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">nu10   </td><td class="markdownTableBodyLeft">The null directive has no effect.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md67"></a>
3.10 The processor-dependent directive</h2>
<p>Example syntax: </p><div class="fragment"><div class="line"><span class="preprocessor"># token-list EOL</span></div>
<div class="line"><span class="preprocessor"></span>...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md68"></a>
3.10.1 Static semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">nd02   </td><td class="markdownTableBodyLeft">The token-list in a processor-dependent directive may not begin with any of the directive names appearing in the syntax above (<code>define</code>, <code>undef</code>, <code>include</code>, etc.).   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md69"></a>
3.10.2 Evaluation semantics specifications</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">nd20   </td><td class="markdownTableBodyLeft">The result of evaluating a processor-dependent directive is processor-dependent.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md70"></a>
4 Macro identification and expansion</h1>
<dl class="section note"><dt>Note</dt><dd>This section is currently incomplete. A self-contained specification for macro identification and expansion will appear in a forthcoming paper.</dd></dl>
<h2><a class="anchor" id="autotoc_md71"></a>
4.1 Comparison to macro identification and expansion in CPP</h2>
<p>We intend for macro identification and expansion to operate almost exactly as specified in C 2023 section 6.10.5, however it will differ in minor ways to accommodate Fortran syntax. The following exceptions have consensus amongst the authors:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">me10   </td><td class="markdownTableBodyLeft">When determining argument boundaries in the invocation of a function-like macro, FPP ignores commas surrounded by matching sets of <code>[ ]</code> or <code>(/ /)</code> brackets, in addition to matching sets of <code>( )</code> parentheses (as specified in C 2023 section 6.10.5-11).   </td></tr>
</table>
<p>Additional details are still under discussion and will be outlined in a future paper.</p>
<h2><a class="anchor" id="autotoc_md72"></a>
4.2 The identifiers __VA_ARGS__ and __VA_OPT__</h2>
<p>As specified in C 2023 section 6.10.5.1, see also section 4.1 above.</p>
<h2><a class="anchor" id="autotoc_md73"></a>
4.3 The # and ## operators</h2>
<p>As specified in C 2023 section 6.10.5.{2,3}, see also section 4.1 above.</p>
<h1><a class="anchor" id="autotoc_md74"></a>
5 Expressions allowed in if and elif directives</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ex05   </td><td class="markdownTableBodyLeft">When evaluating a <code>#if</code> or <code>#elif</code> directive, first every instance of the 'defined ID' or 'defined(ID)' operator is evaluated and replaced with the resulting WHOLE_NUMBER. A 'defined' expression evaluates to 1 if the identifier is currently defined as a macro name (that is, if it is predefined or if it has been the subject of a <code>#define</code> preprocessing directive without an intervening undef directive with the same subject identifier), 0 if it is not.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ex10   </td><td class="markdownTableBodyLeft">When evaluating a <code>#if</code> or <code>#elif</code> directive and after 'defined' processing described in ex05, the token-list is then subjected to macro expansion and replacement (see section 4 "Macro identification and expansion"). This results in a token-list of the expression to be evaluated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ex12   </td><td class="markdownTableBodyLeft">Since expression evaluation occurs <em>after</em> macro expansion, there will be no object-like macro or function-like macro invocations left to expand. All remaining IDs are replaced with the WHOLE_NUMBER 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ex15   </td><td class="markdownTableBodyLeft">The resulting list of tokens shall be a valid expression comprised of WHOLE_NUMBERs and operators as described below.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ex17   </td><td class="markdownTableBodyLeft">Preprocessing computes the integer value of conditional expressions using the greatest integer range available to the processor to determine the truth or falsity of the controlling expression.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ex20   </td><td class="markdownTableBodyLeft">The processor shall reject a program if evaluation of the expression generates a computational error (such as divide by zero).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ex25   </td><td class="markdownTableBodyLeft">When the expression evaluates to zero, the controlling expression will be considered "false". If the expression evaluates to any non-zero value, the controlling expression will be considered "true".   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md75"></a>
5.1 Operators allowed in controlling expressions</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">op01   </td><td class="markdownTableBodyLeft">To maintain compatibility with the use of C preprocessing directives in many existing Fortran programs, the operators allowed in controlling expressions in if and <code>#elif</code> expressions are a subset of those defined in C 2023 section 6.5 "Expressions" and section 6.6 "Constant expressions".    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">op03   </td><td class="markdownTableBodyLeft">A "precedence level" is assigned to each operator that determines how the operators combine with sub-expressions containing other operators at different precedence levels.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">op05   </td><td class="markdownTableBodyLeft">An "associativity" is assigned to each operator that determines how operators at the same precedence level are combined. "left" means the operator binds to the left, "right" means the operator binds to the right.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">op07   </td><td class="markdownTableBodyLeft">The following table describes the semantics of the allowed operators in controlling expressions. The table is grouped by precedence level, from lowest precedence to highest. We label subexpressions "e1", "e2", and "e3" to aid in describing the evaluation semantics. Unless otherwise specified, all operators evaluate with the same semantics as their Fortran counterparts.   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Prec   </th><th class="markdownTableHeadLeft">Op   </th><th class="markdownTableHeadLeft">Syntax   </th><th class="markdownTableHeadLeft">Assoc'y   </th><th class="markdownTableHeadLeft">Evaluation Semantics    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">low   </td><td class="markdownTableBodyLeft">? :   </td><td class="markdownTableBodyLeft">e1 ? e2 : e3   </td><td class="markdownTableBodyLeft">right   </td><td class="markdownTableBodyLeft">conditional expression (see op14)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&amp;#124;&amp;#124;   </td><td class="markdownTableBodyLeft">e1 &amp;#124;&amp;#124; e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">logical OR (see op12)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&amp;&amp;   </td><td class="markdownTableBodyLeft">e1 &amp;&amp; e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">logical AND (see op13)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft" rowspan="2">&amp;#124;   </td><td class="markdownTableBodyLeft">e1 &amp;#124; e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">Fortran IOR(e1, e2)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">e1 ^ e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">Fortran IAND(e1, e2)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&amp;   </td><td class="markdownTableBodyLeft">e1 &amp; e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">Fortran IEOR(e1, e2)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">==   </td><td class="markdownTableBodyLeft">e1 == e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">1 if e1 == e2, 0 otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">!=   </td><td class="markdownTableBodyLeft">e1 != e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">1 if e1 /= e2, 0 otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&gt;   </td><td class="markdownTableBodyLeft">e1 &gt; e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">1 if e1 &gt; e2, 0 otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&gt;=   </td><td class="markdownTableBodyLeft">e1 &gt;= e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">1 if e1 &gt;= e2, 0 otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&lt;   </td><td class="markdownTableBodyLeft">e1 &lt; e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">1 if e1 &lt; e2, 0 otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&lt;=   </td><td class="markdownTableBodyLeft">e1 &lt;= e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">1 if e1 &lt;= e2, 0 otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&lt;&lt;   </td><td class="markdownTableBodyLeft">e1 &lt;&lt; e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">Fortran SHIFTL(e1, e2)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&gt;&gt;   </td><td class="markdownTableBodyLeft">e1 &gt;&gt; e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">Fortran SHIFTR(e1, e2)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">+   </td><td class="markdownTableBodyLeft">e1 + e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">+    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">-   </td><td class="markdownTableBodyLeft">e1 - e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">*   </td><td class="markdownTableBodyLeft">e1 * e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">*    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">/   </td><td class="markdownTableBodyLeft">e1 / e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">/    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">%   </td><td class="markdownTableBodyLeft">e1 % e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">Fortran MOD(e1, e2)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">unary +   </td><td class="markdownTableBodyLeft">+ e1   </td><td class="markdownTableBodyLeft">right   </td><td class="markdownTableBodyLeft">unary +    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">unary -   </td><td class="markdownTableBodyLeft">- e1   </td><td class="markdownTableBodyLeft">right   </td><td class="markdownTableBodyLeft">unary -    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">unary ~   </td><td class="markdownTableBodyLeft">~ e1   </td><td class="markdownTableBodyLeft">right   </td><td class="markdownTableBodyLeft">Fortran NOT(e1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">unary !   </td><td class="markdownTableBodyLeft">! e1   </td><td class="markdownTableBodyLeft">right   </td><td class="markdownTableBodyLeft">1 if e1 == 0, 0 otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">high   </td><td class="markdownTableBodyLeft">( e1 )   </td><td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">N/A   </td><td class="markdownTableBodyLeft">e1   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">op12   </td><td class="markdownTableBodyLeft">The logical OR operator guarantees left-to-right evaluation; if the first operand evaluates to non-zero, the second operand is not evaluated and the resulting value is 1. Otherwise, the second operand is evaluated, and if that evaluation yields 0 the resulting value is 0, otherwise the resulting value is 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">op13   </td><td class="markdownTableBodyLeft">The logical AND operator guarantees left-to-right evaluation; if the first operand evaluates to 0, the second operand is not evaluated and the resulting value is 0. Otherwise, the second operand is evaluated, and if that evaluation yields 0 the resulting value is 0, otherwise the resulting value is 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">op14   </td><td class="markdownTableBodyLeft">The conditional expression 'e1 ? e2 : e3' guarantees left-to-right evaluation; if the first operand e1 evaluates to non-zero, then the third operand e3 is not evaluated and the resulting value is the value of evaluating the second operand e2. Otherwise, the second operand e2 is not evaluated and the resulting value is the value of evaluating the third operand e3.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md76"></a>
7 Predefined macros</h1>
<table class="doxtable">
<tr>
<td>pm00 </td><td><p class="starttd">Macro names beginning with a leading underscore followed by an uppercase letter or a second underscore are reserved to the processor. If a macro with a reserved name is the subject of a define or undef directive within the program unit, then behavior is processor-dependent.</p>
<dl class="section note"><dt>Note</dt><dd>Any macro name matching the regular expression <code>/^_[A-Z_][A-Za-z0-9_]*$/</code> is considered reserved. </dd></dl>
</td></tr>
<tr>
<td>pm01 </td><td>Any macro name predefined by the processor shall begin with a leading underscore followed by an uppercase letter or a second underscore. </td></tr>
<tr>
<td>pm02 </td><td>The processor shall not predefine the macro <code>__cplusplus</code>, nor any macro whose name starts with <code>__STDC</code>. </td></tr>
<tr>
<td>pm03 </td><td>Unless listed in the following subclauses, the processor shall not predefine any macro whose name starts with <code>__STDF</code> or <code>__stdf</code>. </td></tr>
<tr>
<td>pm10 </td><td>The values of the predefined macros listed in the following subclauses (except for <code>__FILE__</code> and <code>__LINE__</code>) remain constant throughout the program unit. </td></tr>
<tr>
<td>pm12 </td><td>The identifier <code>defined</code> shall not be the subject of a define or a <code>#undef</code> preprocessing directive. </td></tr>
<tr>
<td>pm15 </td><td>The presumed source file name and line number can be changed by the <code>#line</code> directive. </td></tr>
<tr>
<td></td><td></td></tr>
</table>
<p>The following macro names shall be defined by the processor:</p>
<h2><a class="anchor" id="autotoc_md77"></a>
7.1 __LINE__</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">pm20   </td><td class="markdownTableBodyLeft"><code>__LINE__</code> shall be predefined to a WHOLE_NUMBER representing the presumed line number (within the current source file) of the current line.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md78"></a>
7.2 __FILE__</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">pm30   </td><td class="markdownTableBodyLeft"><code>__FILE__</code> shall be predefined to a CHARACTER_STRING representing the presumed name of the current source file   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md79"></a>
7.3 __DATE__</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">pm40   </td><td class="markdownTableBodyLeft"><code>__DATE__</code> shall be predefined to a CHARACTER_STRING representing the date of translation of the preprocessing program unit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">pm41   </td><td class="markdownTableBodyLeft"><code>__DATE__</code> shall be a character literal constant of the form "Mmm dd yyyy", where the names of the months are the same as those specified in C 2023 for the asctime function, and the first character of "dd" is a space character if the value is less than 10.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">pm42   </td><td class="markdownTableBodyLeft">If the date of translation is not available, a processor-dependent valid date shall be supplied.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md80"></a>
7.4 __TIME__</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">pm50   </td><td class="markdownTableBodyLeft"><code>__TIME__</code> shall be predefined to a CHARACTER_STRING representing the time of translation of the preprocessing program unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">pm51   </td><td class="markdownTableBodyLeft"><code>__TIME__</code> shall be a character literal constant of the form "hh:mm:ss", where "hh" is the hour of the day, "mm" is the minutes of the hour, and "ss" is the seconds of the minute.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">pm52   </td><td class="markdownTableBodyLeft">If the time of translation is not available, a processor-dependent valid time shall be supplied.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md81"></a>
7.5 __STDF__</h2>
<p><code>__STDF__</code> is an analog to <code>__STDC__</code> in C and <code>__cplusplus</code> in C++. Its primary role is to provide preprocessor-visible and vendor-independent identification of the underlying target language (i.e., "the processor is Fortran"), which enables one to write multi-language header files with conditional compilation based on language.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">pm61   </td><td class="markdownTableBodyLeft"><code>__STDF__</code> shall be predefined to the WHOLE_NUMBER 1   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md82"></a>
8 INCLUDE line processing</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ic01   </td><td class="markdownTableBodyLeft">After macro expansion takes place on a given Fortran source fragment, it may contain a Fortran 'INCLUDE' line. 'INCLUDE' line replacement occurs during preprocessing and is handled analogously to <code>#include</code> directives (as specified in section 3.4 "The `#include` directive").    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ic03   </td><td class="markdownTableBodyLeft">The source text included via an 'INCLUDE' line is subject to preprocessing. After the INCLUDE line is replaced with the source text of the included file, preprocessing continues at the first line of the replacement text.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ic07   </td><td class="markdownTableBodyLeft">An 'INCLUDE' line can be generated by macro expansion (unlike <code>#include</code> directives).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ic10   </td><td class="markdownTableBodyLeft">Included text may contain any source text, including additional 'INCLUDE' lines.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ic11   </td><td class="markdownTableBodyLeft">An 'INCLUDE' line is permitted to directly or indirectly result in the inclusion of the same source text.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ic12   </td><td class="markdownTableBodyLeft">The maximum depth of nesting of any nested INCLUDE lines is processor-dependent (analogously to in26).   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md83"></a>
9 Translation limits</h1>
<p>To enhance portability of source translated by the Fortran preprocessor, the standard shall specify minimum translation limits for conforming processors, governing various aspects of preprocessing source text. Program units exceeding the specified limits might not be acceptable to all processors.</p>
<p>Specific minimum values for the limits will be the subject of a future paper, but are expected to include at least the number of:</p>
<ul>
<li>Nesting levels of conditional compilation directives</li>
<li>Characters in a macro name</li>
<li>Macro identifiers simultaneously defined in one program unit</li>
<li>Characters in a string literal</li>
<li>Parameters in one function-like macro definition</li>
<li>Arguments in one function-like macro invocation</li>
<li>Nesting levels for <code>#include</code> files</li>
</ul>
<h1><a class="anchor" id="autotoc_md84"></a>
Appendix A: Divergences from C</h1>
<p>In many ways, the FPP specified by this document adheres to the existing practice established by the C preprocessor over the past several decades. However FPP semantics also deliberately diverge from the analogous behavior of the C preprocessor as specified in C 2023. This non-normative section enumerates such deliberate differences, as a reference for readers to assist in comparisons.</p>
<p>General differences include:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">dfc10   </td><td class="markdownTableBodyLeft">FPP does not recognize '//'-style comments on directive lines.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">dfc20   </td><td class="markdownTableBodyLeft">FPP omits the embed directive added in C 2023.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">dfc30   </td><td class="markdownTableBodyLeft">FPP omits (and forbids) many predefined macros whose names begin with <code>__STDC</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">dfc40   </td><td class="markdownTableBodyLeft">FPP expands macro invocations inside Fortran comments on Fortran source fragment lines and in Fortran comment lines.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">dfc60   </td><td class="markdownTableBodyLeft">The token-list in the FPP pragma directive may not be empty.   </td></tr>
</table>
<p>Differences in the controlling expression grammar for if and elif directives include:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Code   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">dfc80   </td><td class="markdownTableBodyLeft">FPP omits the comma operator.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">dfc82   </td><td class="markdownTableBodyLeft">FPP omits character literal constants.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">dfc84   </td><td class="markdownTableBodyLeft">FPP omits the 'true' and 'false' boolean literals added in C 2023.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">dfc86   </td><td class="markdownTableBodyLeft">FPP omits the <code>__has_include</code> expression added in C 2023.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">dfc88   </td><td class="markdownTableBodyLeft">FPP omits the <code>__has_c_attribute</code> expression added in C 2023.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">dfc90   </td><td class="markdownTableBodyLeft">FPP omits the <code>__has_embed</code> expression added in C 2023.   </td></tr>
</table>
<p>Differences in macro identification and expansion are currently documented explicitly in section 4.1.</p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="pages.html">Documentation</a></li><li class="navelem"><a class="el" href="j3.html">J3 specifications</a></li>
    <li class="footer">
    &copy; Copyright 2017 - 2024
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
