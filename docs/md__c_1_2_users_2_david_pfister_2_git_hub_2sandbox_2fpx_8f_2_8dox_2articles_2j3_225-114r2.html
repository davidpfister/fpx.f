<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="dark-mode">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.12.0"/>
  <title>fpx.f: 25-114r2</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeFragmentCopyButton.init()
      DoxygenAwesomeDarkModeToggle.init()
      DoxygenAwesomeParagraphLink.init()
      DoxygenAwesomeInteractiveToc.init()
      DoxygenAwesomeTabs.init()
  </script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script>
$(function() {
	hljs.configure({useBR: false});
	$(".fragment").each(function(i,node) {
		$(node).removeClass("fragment");
		hljs.highlightBlock(node);
	});
});
</script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectlogo"><img alt="Logo" src="logo.png" /></td>
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">fpx.f</a>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__c_1_2_users_2_david_pfister_2_git_hub_2sandbox_2fpx_8f_2_8dox_2articles_2j3_225-114r2.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">25-114r2</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="requirements"></a>
Fortran preprocessor requirements</h1>
<h2><a class="anchor" id="autotoc_md22"></a>
Introduction</h2>
<blockquote class="doxtable">
<p>&zwj;From paper 96-063, April 3, 1996 (lightly edited):</p>
<p>Frequently Fortran programmers need to maintain more than one version of a code, or to run the code in various environments. The easiest solution for the programmer is to keep a single source file that has all the code variations interleaved within it so that any version can be easily extracted. This way, modifications that apply to all versions need only be made once.</p>
<p>Source code preprocessors have long been used to provide these capabilities. They allow the user to insert directive statements within the source code that affect the output of the preprocessor. In general, source code preprocessors permit the user to define special variables and logical constructs that conditionally control which source lines in the file are passed on to the compiler and which lines are skipped over. In addition, the preprocessor's capabilities allow the user to specify how the source code should be changed according to the value of defined string variables and functions.</p>
<p>Historically, the source code preprocessor found in standard C compilers, CPP, has been used to provide Fortran programmers with these capabilities. However, CPP is too closely tied into the C language syntax and source line format to be used without careful scrutiny. The proposed Fortran PreProcessor, FPP, would provide Fortran-specific source code capabilities that C programmers have long grown to expect.</p>
<p>&gt;&lt;end of text borrowed from 96-063&gt; </p>
</blockquote>
<p>Existing compiler implementations either use CPP directly, or implement Fortran-oriented semantics of CPP in the processor. For simple use cases, these implementations support similar functionality and behavior.</p>
<p>Many existing Fortran projects make extensive use of C preprocessor directives and macro expansion, despite the lack of an FPP standard. This is usually done to tailor the code to specific environments, such as target compilers or machines.</p>
<p>Unfortunately, more complex use cases fail to be portable between different implementations. This is enough of a problem that WG 5 raised this as the number 2 issue to address in Fortran 202y, behind generics.</p>
<p>This is not a new problem, as evidenced by the J3 discussions from the mid 1990s. The introduction of CoCo in Fortran 95 did not solve the problem, either, because it was not a mandatory part of the standard and because it was not compatible with the preprocessor syntax used by many existing Fortran projects.</p>
<p>This document attempts to define the requirements for a mandatory Fortran preprocessor based on the preprocessor syntax already in common use today. The guiding principle is to promote Fortran program portability by defining consistent syntax and semantics of a useful subset of CPP. Some FPP behavior will be slightly different from CPP, in order to accommodate some Fortran idiosyncrasies.</p>
<p>A major overarching goal of this effort is to standardize de facto current practice for preprocessing in Fortran compilers and code. It is the standard's responsibility to standardize syntax in order to settle minor divergences that have arisen amongst pre-standard FPP implementations, to the detriment of portability for end users.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
The basic idea: phases before the "processor"</h2>
<p>The preprocessor will be a mandatory part of the language. Any file passed to a processor may contain preprocessor directive lines.</p>
<p>The C standards define eight phases of the compilation process. These phases don't prescribe the details of an implementation, but are useful for defining in focused terms the expected behavior of implementations.</p>
<p>We plan to take a similar approach for defining FPP. This should simplify the explanation of the expected behavior of any given implementation.</p>
<h2><a class="anchor" id="autotoc_md24"></a>
FPP Phase 1: Line conjoining</h2>
<p>The C language defines phase 2 as a pass where continuation lines are removed. To simplify the explanation of FPP's preprocessing phase 2, we will define phase 1 to simply remove continuation lines seen in the source file. This will apply to both fixed-form and free-form source Fortran lines and preprocessor directive lines. The output of this phase is a sequence of "logical lines", each of which may be up to 1 million characters long. Logical lines are a sequence of strings and comment-strings in the same order as they are encountered in the input stream.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
FPP Phase 2: Directive processing</h2>
<p>The directive processing phase is analogous to CPP phase 4. Preprocessor directives are executed. Macros are expanded in non-directive lines (Fortran source lines).</p>
<p>The directive language accepted by FPP is based on the syntax of CPP. It has syntax that differs from Fortran, but macros can expand to include arbitrary Fortran tokens. It differs from C and Fortran syntax in the following ways.</p>
<p>Token recognition:</p><ol type="1">
<li>FPP's directives and token recognition are case sensitive.</li>
<li>FPP treats blanks adjacent to tokens as significant, even in fixed-form source files.</li>
</ol>
<p>Line continuation in directives:</p><ol type="1">
<li>FPP directive lines accept backslash () for line continuations.</li>
<li>FPP does not recognize fixed-form (column 6) or free-form (&amp;) continuations on directive lines.</li>
</ol>
<p>Comment handling:</p><ol type="1">
<li>FPP does not recognize '!' as initiating a comment on directive lines. In if and elif directive expressions, '!' is interpreted as the C 'not' operator.</li>
<li>FPP does not recognize '//' as initiating a comment on directive lines. '//' can be used to construct macro definitions that contain Fortran string concatenation.</li>
<li>FPP recognizes /* ... */ C-style comments on directive lines. /* ... */ comments are not recognized in (non-directive) Fortran source lines.</li>
<li>On (non-directive) Fortran source lines, macros are expanded within all Fortran-style comment lines (i.e., as defined by clauses 6.3.2.3 and 6.3.3.2 in the Fortran 2023 interpretation document). This notably implies macro expansion within processor- specific "directive-style" comment lines (such as '!$omp', or '!$acc', or others).</li>
</ol>
<p>Constant expressions in if and elif:</p><ol type="1">
<li>Expressions in if and elif directives allow most operators from CPP (see section 4.3 below).</li>
<li>Expressions in if and elif directives must be integer constant expressions as specified for CPP and evaluate to INTEGER values. As in CPP, zero values are treated as 'false'. Non-zero values are treated as 'true'.</li>
<li>Any undefined identifiers that remain after macro expansion (including those lexically identical to keywords or intrinsics) are treated as zero, as in CPP.</li>
<li>C character constants (such as 'A', '<br  />
') are treated as integer values, as they are in CPP.</li>
<li>There are no KIND specifiers on integer constants in the preprocessor.</li>
<li>Integer expressions in preprocessor directives are evaluated using the integer kind that has the largest decimal exponent range supported by the processor.</li>
</ol>
<h3><a class="anchor" id="autotoc_md26"></a>
Directives accepted by the preprocessor</h3>
<p>The following preprocessor directives will have the same semantics as defined in the C23 edition of the C programming language standard.</p><ul>
<li>line</li>
<li>define including function-like macros and those that use the ellipsis notation in the parameters</li>
<li>undef</li>
<li>if, elif, else, endif</li>
<li>ifdef, ifndef, elifdef, elifndef</li>
<li>include</li>
<li>error</li>
<li>warning</li>
<li>pragma</li>
</ul>
<p>Just as include lines interpolate the source from other files, the preprocessor will include the text from Fortran INCLUDE lines. Text interpolated by INCLUDE lines will be treated as if it had been included via include.</p>
<h3><a class="anchor" id="autotoc_md27"></a>
Tokens recognized in define directives</h3>
<p>The following tokens are recognized in the replacement-list of a define directive and handled by the preprocessor during expansion:</p>
<ul>
<li><code>#</code> (stringify operator)</li>
<li><code>##</code> (token concatenation operator)</li>
<li>Any previously defined macro name</li>
<li>Any argument name in a function-like macro</li>
<li><code>__VA_ARGS__</code> in the replacement-list of a function-like macro that uses the ellipsis notation in the parameters.</li>
<li><code>__VA_OPT__</code> in the replacement-list of a function-like macro that use the ellipsis notation in the parameters.</li>
</ul>
<p>Any other text in the replacement-list is preserved unchanged during macro expansion, and may for example include any tokens valid in Fortran or C.</p>
<h3><a class="anchor" id="autotoc_md28"></a>
Operators accepted in if and elif expressions</h3>
<ul>
<li>The "defined" operator</li>
<li>From C: <br  />
 <code>&amp;&amp;</code> <code>||</code> <code>!</code> (logical operators) <br  />
 <code>==</code> <code>!=</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> (equality- and relational-expression) <br  />
 <code>+</code> <code>-</code> (additive-expression, also unary forms) <br  />
 <code>*</code> <code>/</code> <code>%</code> (multiplicative-expression) <br  />
 <code>&amp;</code> <code>|</code> <code>^</code> <code>~</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> (bitwise operators) <br  />
 <code>? :</code> (conditional-expression) <br  />
 <code>(</code> <code>)</code> (parenthetical grouping) <br  />
</li>
</ul>
<p>Earlier revisions of this document considered allowing Fortran syntax in if and elif expressions, such as: <code>=</code> <code>/=</code> <code>.AND.</code> <code>.OR.</code> <code>.NOT.</code> <code>.TRUE.</code> <code>.FALSE.</code> but we eventually decided to omit these due to a lack of compelling use cases.</p>
<h3><a class="anchor" id="autotoc_md29"></a>
Macros defined by the preprocessor</h3>
<p><b>LINE</b> <b>FILE</b> <b>DATE</b> <b>TIME</b> <b>STDF</b></p>
<p><code>__STDF__</code> is an analog to <code>__STDC__</code> in C and <code>__cplusplus</code> in C++. Its primary role is to provide preprocessor-visible and vendor-independent identification of the underlying target language (i.e., "the processor
is Fortran"), which enables one to write multi-language header files with conditional compilation based on language.</p>
<h3><a class="anchor" id="autotoc_md30"></a>
Fortran awareness during macro expansion</h3>
<p>Just as CPP does not expand tokens in strings, there are places in Fortran lines that FPP should not recognize or expand tokens.</p>
<p>FPP will not expand in fixed-form:</p><ul>
<li>A token "C" or "c" in column 1.</li>
<li>Anything in column 6.</li>
</ul>
<p>FPP will not expand tokens in either fixed- or free-form:</p><ul>
<li>In character literal constants.</li>
<li>In character string edit descriptors (quoted character strings).</li>
</ul>
<p>If alternative syntax for character literal constants is available, FPP will not expand tokens in either fixed- or free-form:</p><ul>
<li>In the alternative syntax for character literal constants.</li>
<li>In the alternative syntax for character string edit descriptors.</li>
</ul>
<h3><a class="anchor" id="autotoc_md31"></a>
Output of Phase 2</h3>
<p>Similar to phase 1, the output is a sequence of logical lines where the logical lines contain the strings representing the now-preprocessed characters of the input file and comment-strings. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2024
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
