<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="dark-mode">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.12.0"/>
  <title>fpx.f: 25-142r2</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeFragmentCopyButton.init()
      DoxygenAwesomeDarkModeToggle.init()
      DoxygenAwesomeParagraphLink.init()
      DoxygenAwesomeInteractiveToc.init()
      DoxygenAwesomeTabs.init()
  </script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script>
$(function() {
	hljs.configure({useBR: false});
	$(".fragment").each(function(i,node) {
		$(node).removeClass("fragment");
		hljs.highlightBlock(node);
	});
});
</script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectlogo"><img alt="Logo" src="logo.png" /></td>
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">fpx.f</a>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__c_1_2_users_2_david_pfister_2_git_hub_2sandbox_2fpx_8f_2_8dox_2articles_2j3_225-142r2.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">25-142r2</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="specifications"></a>
Preprocessor Specifications</h1>
<h2><a class="anchor" id="autotoc_md32"></a>
Introduction</h2>
<p>At its meeting Feb 19, 2025, J3 decided to approve requirements for a cpp-like preprocessor for Fortran 202Y (paper 25-114r2).</p>
<p>This is the formal specifications document, revised according to the discussion arising from 25-114r2.</p>
<p>Terminology: For the purpose of this specification, the "preprocessor" encompasses all stages of preprocessing of the input text. For didactic purposes, that might include additional phases of "preprocessing" that help define the expected priorities of preprocessing behaviors. (In past discussions, these have included line continuation processing, comment handling, and tokenization for the preprocessor.)</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Lexical specifications</h2>
<h3><a class="anchor" id="autotoc_md34"></a>
Lines</h3>
<p>||| |:-&mdash;|:&mdash;| |li00|The Fortran preprocessor recognizes three distinct types of lines: preprocessing directives (and continuation lines thereof), Fortran comment lines, and Fortran source fragments.| |li11|A line that has a '#' character as the first non-blank character of the line is a directive line (as required by C 2023 section 6.10.1 paragraph 2), except when otherwise specified by the next two rules.| |li13|In fixed source form, a '#' in column 6 of a non-comment line does not introduce a directive line.| |li15|A preprocessor directive can be continued with a backslash '\' immediately followed by a new-line. The backslash and new-line are deleted, the content of the subsequent line is textually appended to the current directive, and the subsequent line is deleted. This process repeats until the current directive does not end with a backslash '\' immediately followed by a new-line.| |li17|Preprocessor directive continuation processing described by the prior rule is effectively performed before any other processing of the text in affected lines.| |li19|The maximum length of a preprocessor directive (including continuation text) is one million characters.| |li21|A source file that ends with a directive line shall neither end with a '\', nor a '\' followed immediately by a new-line (analogously to C 2023 section 5.1.1.2 bullet 2).| |li31|Fortran comment lines are defined as in 25-007 6.3.2.3 and 6.3.3.2.| |li41|Fortran source fragments are those lines that are neither preprocessor directive lines (or continuations thereof) nor Fortran comment lines.| |li43|Text on fixed-form Fortran source fragments is ignored beyond column 72.| |li45|Fortran source fragments may be continued with a continuation ('&amp;' at the end of a free-form line as specified in Fortran 2023 6.3.2.4, or with a non-blank, non-zero character in column 6 of a fixed-form line as specified in Fortran 2023 6.3.3.3).| |||</p>
<p><b>Example 1 (free-form)</b>: </p><div class="fragment"><div class="line">    <span class="keyword">call </span>subroutine_foo(1, 2, &amp;</div>
<div class="line"><span class="preprocessor">#ifdef USE_3</span></div>
<div class="line"><span class="preprocessor"></span>                            3, &amp;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>                            666, &amp;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>                            .true.)</div>
<div class="line">`` </div>
<div class="line"><span class="comment">**Example 2 (fixed-form)**:</span></div>
</div><!-- fragment --><p> fortran call subroutine_foo(1, 2, ifdef USE_3 1 3, else 1 666, endif 2 .true.) </p><div class="fragment"><div class="line">### Case sensitivity of identifiers</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|cs01|Directive names are case-sensitive and recognized in lower-case.|</div>
<div class="line">|cs03|Macro names and function-like macro argument names are case-sensitive.|</div>
<div class="line">|cs05|Predefined macro names are case-sensitive.|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">### Significance of whitespace</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|ws01|The whitespace characters blank and horizontal tab character may appear on directive lines.|</div>
<div class="line">|ws02|Whitespace may appear before or after the &#39;#&#39; character that introduces a directive line.|</div>
<div class="line">|ws03|Whitespace characters are significant in determining token boundaries in preprocessor directive lines.|</div>
<div class="line">|ws05|Outside of character constants, multiple whitespace characters on a directive line are treated as a single space.|</div>
<div class="line">|ws07|Whitespace characters are significant in determining token boundaries for the purposes of recognizing macro names, in both fixed-form and free-form Fortran source fragments.|</div>
<div class="line">|ws09|Whitespace characters are significant in determining token boundaries for the purposes of recognizing macro names, in both fixed-form and free-form Fortran comment lines.|</div>
<div class="line">|ws11|In fixed-form input, macro names are not recognized as such when spaces are inserted into their invocations.|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">### Comments</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|co01|Directive lines may contain C-style &#39;/*&#39; ... &#39;*/&#39; comments|</div>
<div class="line">|co05|&#39;/*&#39; ... &#39;*/&#39; comments on directive lines shall extend past a new-line only if the line ends in &#39;\&#39; new-line, indicating a continuation line.|</div>
<div class="line">|co07|&#39;/*&#39; ... &#39;*/&#39; comments on directive lines are replaced by a single space, as specified in C 2023 section 5.1.1.2 bullet 3.|</div>
<div class="line">|co08|In a directive line, the &#39;//&#39; token is not interpreted as introducing a C-style comment, and neither the &#39;//&#39; token nor any subsequent text are removed by the preprocessor.|</div>
<div class="line">|co09|In a directive line, the &#39;!&#39; character is not interpreted as introducing a Fortran-style comment, and neither the &#39;!&#39; character nor any subsequent text are removed by the preprocessor.|</div>
<div class="line">|co11|Directive lines (by definition) cannot contain Fortran fixed-form &#39;C&#39; or &#39;*&#39; style comments.|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">### Token lexicon</div>
<div class="line"> </div>
<div class="line">The preprocessor decomposes the source file into preprocessing tokens</div>
<div class="line">(see C 2023 section 5.1.1.2 Translation phases).</div>
<div class="line"> </div>
<div class="line">As such, there is a specific lexicon of tokens recognized by the</div>
<div class="line">preprocessor (including unrecognizable tokens).</div>
<div class="line"> </div>
<div class="line">As in C 2023, these tokens are recognized after any line and comment</div>
<div class="line">handling specified in section 2.1 &quot;Lines&quot; and section 2.4 &quot;Comments&quot;</div>
<div class="line">above.</div>
<div class="line"> </div>
<div class="line">We use illustrative syntax to describe the directive specifications,</div>
<div class="line">and the translation behavior of the preprocess on Fortran comment</div>
<div class="line">lines and Fortran source fragment lines.</div>
<div class="line"> </div>
<div class="line">This illustrative syntax makes use of these &quot;tokens&quot;.</div>
<div class="line"> </div>
<div class="line">Further definition of the recognized tokens is deferred to the</div>
<div class="line">upcoming preprocessor syntax paper.</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|to01|In the definitions of object macros and function-like macros, the replacement list may include any arbitrary sequence of characters that doesn&#39;t include a new-line. Once tokenized, this for example may include any tokens allowed in Fortran source fragments, those allowed in C integer expressions, and any additional tokens recognized by the processor.|</div>
<div class="line">|to03|Without naming all the tokens explicitly, they appear in the illustrative syntax in subsequent sections.|</div>
<div class="line">|to09|The preprocessor is line-oriented. To define the end of a logical line (after continuation handling), the &#39;EOL&#39; token is shown explicitly in the illustrative syntax.|</div>
<div class="line">|to11|The following tokens also appear in the illustrative syntax below.|</div>
<div class="line"> </div>
<div class="line">|Token name|Characters|</div>
<div class="line">|:----|:---|</div>
<div class="line">| ID                  | Regex [A-Za-z_][A-Za-z0-9_]*          |</div>
<div class="line">| WHOLE_NUMBER        | Regex [0-9]+                          |</div>
<div class="line">| CHARACTER_STRING    | Regex &quot;[^&quot;\n]*&quot; where &#39;\n&#39; represents new-line.|</div>
<div class="line">| EOL                 | The new-line ending a directive line, after continuation processing (see li15).|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">## #-Directives</div>
<div class="line"> </div>
<div class="line">The following directives are recognized during Fortran preprocessing.</div>
<div class="line">Detailed specifications for each directive appear in the subsections</div>
<div class="line">below.</div>
<div class="line"> </div>
<div class="line">We use illustrative syntax in the detailed descriptions. Detailed</div>
<div class="line">syntax will appear in a paper to be named later.</div>
<div class="line"> </div>
<div class="line">Most directives take a sequence of tokens (as defined in section 2.5</div>
<div class="line">&quot;Token lexicon&quot; above). In the detailed descriptions and illustrative</div>
<div class="line">syntax below, we denote these as just &quot;token-list&quot; or</div>
<div class="line">&quot;replacement-list&quot;.</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|di00|The directives listed in di01-di08 are only recognized as such if the token immediately following the &#39;#&#39; introducing a directive line exactly matches one of the standard directive names (&#39;define&#39;, &#39;if&#39;, &#39;pragma&#39;, etc.).|</div>
<div class="line">|di01|The #define object-like macro directive|</div>
<div class="line">|di02|The #define function-like macro directive|</div>
<div class="line">|di03|The #undef directive|</div>
<div class="line">|di04|The #include directive|</div>
<div class="line">|di05|The #if, #ifdef, #ifndef, #elif, #elifdef, #elifndef, #else, #endif conditional directives|</div>
<div class="line">|di06|The #error and #warning directives|</div>
<div class="line">|di07|The #line directive|</div>
<div class="line">|di08|The #pragma directive|</div>
<div class="line">|di09|The null directive|</div>
<div class="line">|di10|The processor-dependent directive|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">### The #define object-like macro directive</div>
<div class="line"> </div>
<div class="line">See also the rules for expanding object-like macros in</div>
<div class="line">section 4 &quot;Macro identification and expansion&quot; below.</div>
<div class="line"> </div>
<div class="line">Example syntax:</div>
</div><!-- fragment --><p> fortran define ID replacement-list EOL </p><div class="fragment"><div class="line">#### Static semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|do02|The replacement-list is a (possibly empty) sequence of tokens.|</div>
<div class="line">|do04|The identifier ID must be immediately followed by whitespace or EOL.|</div>
<div class="line">|do06|Whitespace before or after the replacement-list is not considered to be part of the replacement-list.|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">#### Evaluation semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|do20|This #define directive defines an object-like macro named by ID with a replacement list comprised of the tokens specified in the replacement-list.</div>
<div class="line">|do22|There is one name space for all macro names.|</div>
<div class="line">|do24|The #define directive does not scan the replacement-list for macros to expand.|</div>
<div class="line">|do26|An identifier currently defined as an object-like macro shall not be redefined by another #define preprocessing directive unless the second definition is an object-like macro definition and the two replacement lists are identical (as in C 2023).|</div>
<div class="line">|do28|Two replacement lists are identical if and only if the preprocessing tokens in both have the same number, ordering, spelling, and white-space separation, where all white-space separations are considered identical (as in C 2023).|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">### The #define function-like macro directive</div>
<div class="line"> </div>
<div class="line">See also the rules for expanding function-like macros in the</div>
<div class="line">section 4 &quot;Macro identification and expansion&quot; below.</div>
<div class="line"> </div>
<div class="line">Example syntax:</div>
</div><!-- fragment --><p> fortran define ID() replacement-list EOL define ID(identifier-list) replacement-list EOL define ID(...) replacement-list EOL define ID(identifier-list, ...) replacement-list EOL </p><div class="fragment"><div class="line">#### Static semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|df02|The identifier ID must be immediately followed by a left parenthesis &#39;(&#39; with no intervening whitespace.|</div>
<div class="line">|df04|The identifier-list is a comma-separated list of ID tokens.|</div>
<div class="line">|df06|No identifier may appear more than once in the identifier-list.|</div>
<div class="line">|df08|The identifier names in the identifier-list define macro &quot;parameters&quot; that affect macro expansion of the replacement list. (See section 4 &quot;Macro identification and expansion&quot; for the semantics of function-like macro expansion.)|</div>
<div class="line">|df10|The replacement-list may be the empty sequence of tokens.|</div>
<div class="line">|df12|Whitespace before or after the replacement-list is not considered to be part of the replacement-list.|</div>
<div class="line">|df16|The &#39;...&#39; between the parentheses specifies that the function-like macro may be invoked with a variable number of arguments. (See section 4 &quot;Macro identification and expansion&quot; for the semantics of function-like macros with a variable number of arguments.)|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">#### Evaluation semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|df30|This #define directive defines a function-like macro named by ID with the specified macro parameters and with a replacement list comprised of the tokens specified in the replacement-list.|</div>
<div class="line">|df32|This #define directive does not scan the replacement-list for macros to expand.|</div>
<div class="line">|df34|An identifier currently defined as a function-like macro shall not be redefined by another #define preprocessing directive unless the second definition is a function-like macro definition, with the same number and spelling of the parameters, and the two replacement lists are identical (as in C 2023).|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">### The #undef directive</div>
<div class="line"> </div>
<div class="line">Example syntax:</div>
</div><!-- fragment --><p> fortran undef ID EOL </p><div class="fragment"><div class="line">#### Static semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|ud02|ID shall not be one of the macros defined in section 7 &quot;Predefined macros&quot; below.|</div>
<div class="line">|ud04|The specified identifier may or may not have been defined.|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">#### Evaluation semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|ud20|If no definition exists for the identifier ID, this directive has no effect.|</div>
<div class="line">|ud22|The definition for the object-like macro or function-like macro named by ID is removed.|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">### The #include directive</div>
<div class="line"> </div>
<div class="line">Example syntax:</div>
</div><!-- fragment --><p> fortran include CHARACTER_STRING EOL include &lt;character-list&gt; EOL include token-list EOL </p><div class="fragment"><div class="line">#### Static semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|in06|In the second form, the character-list is any sequence of processor-dependent characters except EOL and &#39;&gt;&#39;.|</div>
<div class="line">|in08|In the third form, the token-list does not match the previous two forms.|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">#### Evaluation semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|in18|In the third form, the token-list is processed as in Fortran source fragments (see section 4 &quot;Macro identification and expansion&quot; below). The directive resulting after all replacements shall match one of the previous two forms, and evaluation proceeds as such.|</div>
<div class="line">|in20|The preprocessor searches in processor-defined places for the file denoted by the CHARACTER_STRING or the character-list.|</div>
<div class="line">|in22|It is an error if the processor cannot locate the specified file.|</div>
<div class="line">|in24|If the file is located, the processor replaces the #include directive line with the contents of that file.|</div>
<div class="line">|in26|A #include directive may appear in an included file, up to a processor-defined nesting limit.|</div>
<div class="line">|in28|Unlike INCLUDE lines in Fortran 2023 (see 25-007 section 6.4, &quot;Including source text&quot;), the #include directive is not prohibited from including the same source file at a deeper level of nesting. See also section 8 &quot;INCLUDE line processing&quot;.|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">### The #if, #ifdef, #ifndef, #elif, #elifdef, #elifndef, #else, #endif conditional directives</div>
<div class="line"> </div>
<div class="line">Example syntax (extra spacing for illustration purposes only):</div>
</div><!-- fragment --><p> General form: &lt;if-head&gt; &lt;if-elif-list&gt; endif EOL &lt;if-head&gt; &lt;if-elif-list&gt; &lt;if-else&gt; endif EOL</p>
<p>Where: &lt;if-head&gt; is one of: if token-list EOL &lt;group&gt; ifdef ID EOL &lt;group&gt; ifndef ID EOL &lt;group&gt;</p>
<p>&lt;if-elif-list&gt; is zero or more of: &lt;if-elif&gt;</p>
<p>&lt;if-elif&gt; is one of: elif token-list EOL &lt;group&gt; elifdef ID EOL &lt;group&gt; elifndef ID EOL &lt;group&gt;</p>
<p>&lt;if-else&gt; is one of: else EOL &lt;group&gt;</p>
<p>&lt;group&gt; is zero or more of: directive lines Fortran comment lines Fortran source fragment lines </p><div class="fragment"><div class="line">#### Static semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|if05|An &lt;if-head&gt; is comprised of a #if, #ifdef, or #ifndef directive and signals the start of a &quot;chain&quot; of conditional directives.|</div>
<div class="line">|if15|A series of #elif, #elifdef, and #elifndef directives, and the #else directive (if present) are part of the same chain of directives introduced by the nearest preceding &lt;if-head&gt;.|</div>
<div class="line">|if20|A chain of conditional directives ends with the #endif directive.|</div>
<div class="line">|if25|Within a conditional directive chain, a #if, #ifdef, or #ifndef directive introduces a new chain of conditional directives, at a new nesting level, within the enclosing conditional directive chain.|</div>
<div class="line">|if30|The conditional directive chains must properly nest, with each nested chain appearing entirely within a single &lt;group&gt; of the enclosing chain.|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">#### Evaluation semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|ix05|The #ifdef and #ifndef directives are evaluated as if they had been written &#39;#if defined(ID)&#39; and &#39;#if !defined(ID)&#39; respectively. (For brevity, the descriptions of #ifdef and #ifndef directives below are omitted, and assume this transformation.)|</div>
<div class="line">|ix10|The #elifdef and #elifndef directives are evaluated as if they had been written &#39;#elif defined(ID)&#39; and &#39;#elif !defined(ID)&#39; respectively. (For brevity, the descriptions below assume this transformation has been made).|</div>
<div class="line">|ix12|In the descriptions below, constructs may be &quot;skipped&quot;. When skipped:&lt;ul&gt;&lt;li&gt;Conditional directives within the construct are recognized only to maintain proper nesting of conditional directives.&lt;/li&gt;&lt;li&gt;No nested directives in the construct are processed.&lt;/li&gt;&lt;li&gt;No macro expansion takes place in directive lines, Fortran comment lines or Fortran source fragment lines in the construct.&lt;/li&gt;&lt;li&gt;No skipped lines of any kind in the construct are made available to subsequent processing by the processor.&lt;/li&gt;&lt;/ul&gt;|</div>
<div class="line">|ix14|In the descriptions below, &lt;group&gt; constructs that are not skipped participate in further preprocessing and processing. When participating:&lt;ul&gt;&lt;li&gt;Macros are expanded in Fortran comment lines and Fortran source fragment lines.&lt;/li&gt;&lt;li&gt;Nested directives in the &lt;group&gt; are processed.&lt;/li&gt;&lt;li&gt;The resulting Fortran comment lines and Fortran source fragment lines are made available for subsequent processing by the processor.&lt;/li&gt;&lt;/ul&gt;|</div>
<div class="line">|ix15|Before evaluating the token-lists in any &lt;if-head&gt; and &lt;if-elif&gt; constructs that are not skipped, macros in the token-lists are processed as described in section 4 &quot;Macro identification and expansion&quot;.|</div>
<div class="line">|ix20|After expansion, the resulting token list in &lt;if-head&gt; and &lt;if-elif&gt; constructs that are not skipped must comprise a valid integer expression as described in section 5 &quot;Expressions allowed in #if and #elif directives&quot; static semantics. This expression is called the &quot;controlling expression&quot; for the directive.|</div>
<div class="line">|ix25|The values of controlling expressions in &lt;if-head&gt; and &lt;if-elif&gt; constructs are evaluated according to the evaluation semantics described in section 5 &quot;Expressions allowed in #if and #elif directives&quot;.|</div>
<div class="line">|ix30|If the controlling expression in an &lt;if-head&gt; evaluates to a nonzero value, then the &lt;group&gt; contained within that &lt;if-head&gt; construct participates in further preprocessing, as described above. Subsequent &lt;if-elif&gt; and &lt;if-else&gt; constructs in the same chain are skipped.|</div>
<div class="line">|ix45|If the controlling expression in an &lt;if-head&gt; construct evaluates to a zero value, then the &lt;group&gt; contained within that &lt;if-head&gt; construct is skipped. Preprocessing continues with any &lt;if-elif&gt; constructs in the same chain, as described below.|</div>
<div class="line">|ix50|When the controlling expression in an &lt;if-head&gt; construct evaluates to zero, the controlling expressions in each &lt;if-elif&gt; construct in the same chain are evaluated in turn, until one evaluates to a non-zero value. Those &lt;group&gt;s whose controlling expression evaluates to zero are skipped.|</div>
<div class="line">|ix55|When the controlling expression in an &lt;if-elif&gt; construct evaluates to a nonzero value, the &lt;group&gt; contained within that &lt;if-elif&gt; construct continues to participate in preprocessing. Subsequent &lt;if-elif&gt; constructs and any remaining &lt;if-else&gt; constructs in the same chain are skipped.|</div>
<div class="line">|ix60|When all controlling expressions in the &lt;if-head&gt; construct and &lt;if-elif&gt; constructs evaluate to a zero value and an &lt;if-else&gt; construct is present in the same chain, the &lt;group&gt; contained in the &lt;if-else&gt; construct continues to participate in preprocessing.|</div>
<div class="line">|ix65|When all controlling expressions in the &lt;if-head&gt; construct and all &lt;if-elif&gt; constructs evaluate to a zero value and no &lt;if-else&gt; construct is present in the same chain, then all &lt;group&gt;s in these constructs are skipped.|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">### The #error and #warning directives</div>
<div class="line"> </div>
<div class="line">Example syntax:</div>
</div><!-- fragment --><p> error token-list EOL warning token-list EOL </p><div class="fragment"><div class="line">The #error and #warning directives are used to announce user-defined</div>
<div class="line">error conditions in the input.</div>
<div class="line"> </div>
<div class="line">#### Static semantics specifications</div>
<div class="line"> </div>
<div class="line">#### Evaluation semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|ew02|The token-list is not expanded.|</div>
<div class="line">|ew04|The processor produces a diagnostic message that includes the token-list.|</div>
<div class="line">|ew06|The processor shall reject a submitted program if the processor encounters a #error directive during preprocessing.|</div>
<div class="line">|ew10|Additional behavior is processor-dependent.|</div>
<div class="line"> </div>
<div class="line">### The #line directive</div>
<div class="line"> </div>
<div class="line">Example syntax:</div>
</div><!-- fragment --><p> line WHOLE_NUMBER EOL line WHOLE_NUMBER CHARACTER_STRING EOL </p><div class="fragment"><div class="line">#### Static semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|li02|The WHOLE_NUMBER shall not be zero.|</div>
<div class="line">|li04|The WHOLE_NUMBER shall not exceed 2147483647.|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">#### Evaluation semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|li20|In both forms, the #line directive causes the processor to behave as if the following sequence of lines begins with a presumed line number specified by the WHOLE_NUMBER.|</div>
<div class="line">|li24|In the second form, the #line directive causes the processor to change the presumed file name of the source file to be the contents of the CHARACTER_STRING.|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">### The #pragma directive</div>
<div class="line"> </div>
<div class="line">Example syntax:</div>
</div><!-- fragment --><p> pragma token-list EOL </p><div class="fragment"><div class="line">#### Static semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|pr02|The token-list may not be empty.|</div>
<div class="line">|pr10|The token-list shall not begin with the identifier &#39;STDF&#39;, either before or after macro expansion.|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">#### Evaluation semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|pr20|The semantics of the token-list are processor-dependent. In particular, it is processor-dependent whether macro expansion is performed on the token-list.|</div>
<div class="line">|pr22|The #pragma directive causes the processor to behave in a processor-defined manner.|</div>
<div class="line">|pr24|Any #pragma that is not recognized by the processor is ignored.|</div>
<div class="line"> </div>
<div class="line">### The null directive</div>
<div class="line"> </div>
<div class="line">Example syntax:</div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md35"></a>
EOL</h1>
<div class="fragment"><div class="line">#### Static semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|nu02|The only tokens allowed on a null directive are the &#39;#&#39; and the end-of-line indicator EOL.|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">#### Evaluation semantics specifications</div>
<div class="line"> </div>
<div class="line">|||</div>
<div class="line">|:----|:---|</div>
<div class="line">|nu10|The null directive has no effect.|</div>
<div class="line">|||</div>
<div class="line"> </div>
<div class="line">### The processor-dependent directive</div>
<div class="line"> </div>
<div class="line">Example syntax:</div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md36"></a>
token-list EOL</h1>
<p>```</p>
<h4><a class="anchor" id="autotoc_md37"></a>
Static semantics specifications</h4>
<p>||| |:-&mdash;|:&mdash;| |nd02|The token-list in a processor-dependent directive may not begin with any of the directive names appearing in the syntax above ('define', 'undef', 'include', etc.).| |||</p>
<h4><a class="anchor" id="autotoc_md38"></a>
Evaluation semantics specifications</h4>
<p>||| |:-&mdash;|:&mdash;| |nd20|The result of evaluating a processor-dependent directive is processor-dependent.| |||</p>
<h2><a class="anchor" id="autotoc_md39"></a>
Macro identification and expansion</h2>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] This section is currently incomplete. A self-contained specification for macro identification and expansion will appear in a forthcoming paper. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md40"></a>
Comparison to macro identification and expansion in CPP</h3>
<p>We intend for macro identification and expansion to operate almost exactly as specified in C 2023 section 6.10.5, however it will differ in minor ways to accommodate Fortran syntax. The following exceptions have consensus amongst the authors:</p>
<p>||| |:-&mdash;|:&mdash;| |me10|When determining argument boundaries in the invocation of a function-like macro, FPP ignores commas surrounded by matching sets of '[ ]' or '(/ /)' brackets, in addition to matching sets of '( )' parentheses (as specified in C 2023 section 6.10.5-11).| |||</p>
<p>Additional details are still under discussion and will be outlined in a future paper.</p>
<h3><a class="anchor" id="autotoc_md41"></a>
The identifiers <code>__VA_ARGS__</code> and <code>__VA_OPT__</code></h3>
<p>As specified in C 2023 section 6.10.5.1, see also section 4.1 above.</p>
<h3><a class="anchor" id="autotoc_md42"></a>
The '#' and '##' operators</h3>
<p>As specified in C 2023 section 6.10.5.{2,3}, see also section 4.1 above.</p>
<h2><a class="anchor" id="autotoc_md43"></a>
Expressions allowed in if and elif directives</h2>
<p>||| |:-&mdash;|:&mdash;| |ex05|When evaluating a if or elif directive, first every instance of the 'defined ID' or 'defined(ID)' operator is evaluated and replaced with the resulting WHOLE_NUMBER. A 'defined' expression evaluates to 1 if the identifier is currently defined as a macro name (that is, if it is predefined or if it has been the subject of a define preprocessing directive without an intervening undef directive with the same subject identifier), 0 if it is not.| |ex10|When evaluating a if or elif directive and after 'defined' processing described in ex05, the token-list is then subjected to macro expansion and replacement (see section 4 "Macro identification and expansion"). This results in a token-list of the expression to be evaluated.| |ex12|Since expression evaluation occurs <em>after</em> macro expansion, there will be no object-like macro or function-like macro invocations left to expand. All remaining IDs are replaced with the WHOLE_NUMBER 0.| |ex15|The resulting list of tokens shall be a valid expression comprised of WHOLE_NUMBERs and operators as described below.| |ex17|Preprocessing computes the integer value of conditional expressions using the greatest integer range available to the processor to determine the truth or falsity of the controlling expression.| |ex20|The processor shall reject a program if evaluation of the expression generates a computational error (such as divide by zero).| |ex25|When the expression evaluates to zero, the controlling expression will be considered "false". If the expression evaluates to any non-zero value, the controlling expression will be considered "true".| |||</p>
<h3><a class="anchor" id="autotoc_md44"></a>
Operators allowed in controlling expressions</h3>
<p>||| |:-&mdash;|:&mdash;| |op01|To maintain compatibility with the use of C preprocessing directives in many existing Fortran programs, the operators allowed in controlling expressions in if and elif expressions are a subset of those defined in C 2023 section 6.5 "Expressions" and section 6.6 "Constant expressions".| |op03|A "precedence level" is assigned to each operator that determines how the operators combine with sub-expressions containing other operators at different precedence levels.| |op05|An "associativity" is assigned to each operator that determines how operators at the same precedence level are combined. "left" means the operator binds to the left, "right" means the operator binds to the right.| |op07|The following table describes the semantics of the allowed operators in controlling expressions. The table is grouped by precedence level, from lowest precedence to highest. We label subexpressions "e1", "e2", and "e3" to aid in describing the evaluation semantics. Unless otherwise specified, all operators evaluate with the same semantics as their Fortran counterparts.| |||</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Prec   </th><th class="markdownTableHeadLeft">Op   </th><th class="markdownTableHeadLeft">Syntax   </th><th class="markdownTableHeadLeft">Assoc'y   </th><th class="markdownTableHeadLeft">Evaluation Semantics    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">low   </td><td class="markdownTableBodyLeft">? :   </td><td class="markdownTableBodyLeft">e1 ? e2 : e3   </td><td class="markdownTableBodyLeft">right   </td><td class="markdownTableBodyLeft">conditional expression (see op14)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&amp;#124;&amp;#124;   </td><td class="markdownTableBodyLeft">e1 &amp;#124;&amp;#124; e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">logical OR (see op12)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&amp;&amp;   </td><td class="markdownTableBodyLeft">e1 &amp;&amp; e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">logical AND (see op13)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft" rowspan="2">&amp;#124;   </td><td class="markdownTableBodyLeft">e1 &amp;#124; e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">Fortran IOR(e1, e2)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">e1 ^ e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">Fortran IAND(e1, e2)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&amp;   </td><td class="markdownTableBodyLeft">e1 &amp; e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">Fortran IEOR(e1, e2)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">==   </td><td class="markdownTableBodyLeft">e1 == e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">1 if e1 == e2, 0 otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">!=   </td><td class="markdownTableBodyLeft">e1 != e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">1 if e1 /= e2, 0 otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&gt;   </td><td class="markdownTableBodyLeft">e1 &gt; e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">1 if e1 &gt; e2, 0 otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&gt;=   </td><td class="markdownTableBodyLeft">e1 &gt;= e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">1 if e1 &gt;= e2, 0 otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&lt;   </td><td class="markdownTableBodyLeft">e1 &lt; e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">1 if e1 &lt; e2, 0 otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&lt;=   </td><td class="markdownTableBodyLeft">e1 &lt;= e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">1 if e1 &lt;= e2, 0 otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&lt;&lt;   </td><td class="markdownTableBodyLeft">e1 &lt;&lt; e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">Fortran SHIFTL(e1, e2)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">&gt;&gt;   </td><td class="markdownTableBodyLeft">e1 &gt;&gt; e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">Fortran SHIFTR(e1, e2)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">+   </td><td class="markdownTableBodyLeft">e1 + e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">+    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">-   </td><td class="markdownTableBodyLeft">e1 - e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">*   </td><td class="markdownTableBodyLeft">e1 * e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">*    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">/   </td><td class="markdownTableBodyLeft">e1 / e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">/    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">%   </td><td class="markdownTableBodyLeft">e1 % e2   </td><td class="markdownTableBodyLeft">left   </td><td class="markdownTableBodyLeft">Fortran MOD(e1, e2)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">unary +   </td><td class="markdownTableBodyLeft">+ e1   </td><td class="markdownTableBodyLeft">right   </td><td class="markdownTableBodyLeft">unary +    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">unary -   </td><td class="markdownTableBodyLeft">- e1   </td><td class="markdownTableBodyLeft">right   </td><td class="markdownTableBodyLeft">unary -    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">unary ~   </td><td class="markdownTableBodyLeft">~ e1   </td><td class="markdownTableBodyLeft">right   </td><td class="markdownTableBodyLeft">Fortran NOT(e1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">unary !   </td><td class="markdownTableBodyLeft">! e1   </td><td class="markdownTableBodyLeft">right   </td><td class="markdownTableBodyLeft">1 if e1 == 0, 0 otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">high   </td><td class="markdownTableBodyLeft">( e1 )   </td><td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">N/A   </td><td class="markdownTableBodyLeft">e1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft" colspan="5"></td></tr>
</table>
<p>||| |:-&mdash;|:&mdash;| |op12|The logical OR operator guarantees left-to-right evaluation; if the first operand evaluates to non-zero, the second operand is not evaluated and the resulting value is 1. Otherwise, the second operand is evaluated, and if that evaluation yields 0 the resulting value is 0, otherwise the resulting value is 1.| |op13|The logical AND operator guarantees left-to-right evaluation; if the first operand evaluates to 0, the second operand is not evaluated and the resulting value is 0. Otherwise, the second operand is evaluated, and if that evaluation yields 0 the resulting value is 0, otherwise the resulting value is 1.| |op14|The conditional expression 'e1 ? e2 : e3' guarantees left-to-right evaluation; if the first operand e1 evaluates to non-zero, then the third operand e3 is not evaluated and the resulting value is the value of evaluating the second operand e2. Otherwise, the second operand e2 is not evaluated and the resulting value is the value of evaluating the third operand e3.| |||</p>
<h2><a class="anchor" id="autotoc_md45"></a>
Predefined macros</h2>
<table class="doxtable">
<tr>
<td>pm00 </td><td><p class="starttd">Macro names beginning with a leading underscore followed by an uppercase letter or a second underscore are reserved to the processor. If a macro with a reserved name is the subject of a define or undef directive within the program unit, then behavior is processor-dependent.</p>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] Any macro name matching the regular expression <code>/^_[A-Z_][A-Za-z0-9_]*$/</code> is considered reserved. </p>
</blockquote>
</td></tr>
<tr>
<td>pm01 </td><td>Any macro name predefined by the processor shall begin with a leading underscore followed by an uppercase letter or a second underscore. </td></tr>
<tr>
<td>pm02 </td><td>The processor shall not predefine the macro <code>__cplusplus</code>, nor any macro whose name starts with <code>__STDC</code>. </td></tr>
<tr>
<td>pm03 </td><td>Unless listed in the following subclauses, the processor shall not predefine any macro whose name starts with <code>__STDF</code> or <code>__stdf</code>. </td></tr>
<tr>
<td>pm10 </td><td>The values of the predefined macros listed in the following subclauses (except for <code>__FILE__</code> and <code>__LINE__</code>) remain constant throughout the program unit. </td></tr>
<tr>
<td>pm12 </td><td>The identifier <code>defined</code> shall not be the subject of a define or a undef preprocessing directive. </td></tr>
<tr>
<td>pm15 </td><td>The presumed source file name and line number can be changed by the line directive. </td></tr>
<tr>
<td></td><td></td></tr>
</table>
<p>The following macro names shall be defined by the processor:</p>
<h3><a class="anchor" id="autotoc_md46"></a>
<code>__LINE__</code></h3>
<p>||| |:-&mdash;|:&mdash;| |pm20|'<b>LINE</b>' shall be predefined to a WHOLE_NUMBER representing the presumed line number (within the current source file) of the current line.| |||</p>
<h3><a class="anchor" id="autotoc_md47"></a>
<code>__FILE__</code></h3>
<p>||| |:-&mdash;|:&mdash;| |pm30|<code>__FILE__</code> shall be predefined to a CHARACTER_STRING representing the presumed name of the current source file| |||</p>
<h3><a class="anchor" id="autotoc_md48"></a>
<code>__DATE__</code></h3>
<p>||| |:-&mdash;|:&mdash;| |pm40|<code>__DATE__</code> shall be predefined to a CHARACTER_STRING representing the date of translation of the preprocessing program unit| |pm41|<code>__DATE__</code> shall be a character literal constant of the form "Mmm dd yyyy", where the names of the months are the same as those specified in C 2023 for the asctime function, and the first character of "dd" is a space character if the value is less than 10.| |pm42|If the date of translation is not available, a processor-dependent valid date shall be supplied.| |||</p>
<h3><a class="anchor" id="autotoc_md49"></a>
<code>__TIME__</code></h3>
<p>||| |:-&mdash;|:&mdash;| |pm50|<code>__TIME__</code> shall be predefined to a CHARACTER_STRING representing the time of translation of the preprocessing program unit.| |pm51|<code>__TIME__</code> shall be a character literal constant of the form "hh:mm:ss", where "hh" is the hour of the day, "mm" is the minutes of the hour, and "ss" is the seconds of the minute.| |pm52|If the time of translation is not available, a processor-dependent valid time shall be supplied.| |||</p>
<h3><a class="anchor" id="autotoc_md50"></a>
<code>__STDF__</code></h3>
<p><code>__STDF__</code> is an analog to <code>__STDC__</code> in C and <code>__cplusplus</code> in C++. Its primary role is to provide preprocessor-visible and vendor-independent identification of the underlying target language (i.e., "the processor is Fortran"), which enables one to write multi-language header files with conditional compilation based on language.</p>
<p>||| |:-&mdash;|:&mdash;| |pm61|<code>__STDF__</code> shall be predefined to the WHOLE_NUMBER 1| |||</p>
<h2><a class="anchor" id="autotoc_md51"></a>
INCLUDE line processing</h2>
<p>||| |:-&mdash;|:&mdash;| |ic01|After macro expansion takes place on a given Fortran source fragment, it may contain a Fortran 'INCLUDE' line. 'INCLUDE' line replacement occurs during preprocessing and is handled analogously to 'include' directives (as specified in section 3.4 "The #include directive").| |ic03|The source text included via an 'INCLUDE' line is subject to preprocessing. After the INCLUDE line is replaced with the source text of the included file, preprocessing continues at the first line of the replacement text.| |ic07|An 'INCLUDE' line can be generated by macro expansion (unlike 'include' directives).| |ic10|Included text may contain any source text, including additional 'INCLUDE' lines.| |ic11|An 'INCLUDE' line is permitted to directly or indirectly result in the inclusion of the same source text.| |ic12|The maximum depth of nesting of any nested INCLUDE lines is processor-dependent (analogously to in26).| |||</p>
<h2><a class="anchor" id="autotoc_md52"></a>
Translation limits</h2>
<p>To enhance portability of source translated by the Fortran preprocessor, the standard shall specify minimum translation limits for conforming processors, governing various aspects of preprocessing source text. Program units exceeding the specified limits might not be acceptable to all processors.</p>
<p>Specific minimum values for the limits will be the subject of a future paper, but are expected to include at least the number of:</p>
<ul>
<li>Nesting levels of conditional compilation directives</li>
<li>Characters in a macro name</li>
<li>Macro identifiers simultaneously defined in one program unit</li>
<li>Characters in a string literal</li>
<li>Parameters in one function-like macro definition</li>
<li>Arguments in one function-like macro invocation</li>
<li>Nesting levels for include files</li>
</ul>
<h2><a class="anchor" id="autotoc_md53"></a>
Appendix A: Divergences from C</h2>
<p>In many ways, the FPP specified by this document adheres to the existing practice established by the C preprocessor over the past several decades. However FPP semantics also deliberately diverge from the analogous behavior of the C preprocessor as specified in C 2023. This non-normative section enumerates such deliberate differences, as a reference for readers to assist in comparisons.</p>
<p>General differences include:</p>
<p>||| |:-&mdash;|:&mdash;| |dfc10|FPP does not recognize '//'-style comments on directive lines.| |dfc20|FPP omits the embed directive added in C 2023.| |dfc30|FPP omits (and forbids) many predefined macros whose names begin with <code>__STDC</code>.| |dfc40|FPP expands macro invocations inside Fortran comments on Fortran source fragment lines and in Fortran comment lines.| |dfc60|The token-list in the FPP pragma directive may not be empty.| |||</p>
<p>Differences in the controlling expression grammar for if and elif directives include:</p>
<p>||| |:-&mdash;|:&mdash;| |dfc80|FPP omits the comma operator.| |dfc82|FPP omits character literal constants.| |dfc84|FPP omits the 'true' and 'false' boolean literals added in C 2023.| |dfc86|FPP omits the <code>__has_include</code> expression added in C 2023.| |dfc88|FPP omits the <code>__has_c_attribute</code> expression added in C 2023.| |dfc90|FPP omits the <code>__has_embed</code> expression added in C 2023.| |||</p>
<p>Differences in macro identification and expansion are currently documented explicitly in section 4.1. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2024
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
