<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="dark-mode">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.12.0"/>
  <title>fpx.f: 25-176r3</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeFragmentCopyButton.init()
      DoxygenAwesomeDarkModeToggle.init()
      DoxygenAwesomeParagraphLink.init()
      DoxygenAwesomeInteractiveToc.init()
      DoxygenAwesomeTabs.init()
  </script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script>
$(function() {
	hljs.configure({useBR: false});
	$(".fragment").each(function(i,node) {
		$(node).removeClass("fragment");
		hljs.highlightBlock(node);
	});
});
</script>
  </head>
  <body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
      <tbody>
        <tr style="height: 56px;">
          <td id="projectlogo"><img alt="Logo" src="logo.png" /></td>
          <td id="projectalign" style="padding-left: 0.5em;">
            <div id="projectname">
              <a href="index.html">fpx.f</a>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__c_1_2_users_2_david_pfister_2_git_hub_2sandbox_2fpx_8f_2_8dox_2articles_2j3_225-176r3.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">25-176r3</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="macro"></a>
Macro Expansion</h1>
<h2><a class="anchor" id="autotoc_md54"></a>
Background</h2>
<p>The current Fortran 202Y work list WG5/N2249 includes specifying a Fortran-friendly preprocessor as accepted work item US10.</p>
<p>At meeting #235 in Feb 2025, J3 approved requirements for cpp-like preprocessing (paper 25-114r2).</p>
<p>At meeting #236 in Jun 2025, J3 approved corresponding specifications covering the majority of preprocessing (paper 25-142r2). That document left one incomplete section, section 4 "Macro identification and
expansion".</p>
<p>This document provides the remaining specifications for preprocessing, specifying the details of macro identification and expansion. It should be read along with 25-142r2, which provides all the other specifications.</p>
<p>The first revision of this document (25-176r1) was discussed in plenary at J3 meeting #237 on 2025-10-27. Updates were made based on that discussion, most notably the addition of the "Straw polls" section below; this has been used to resolve controversial issues that arose in the initial discussion and establish clear design direction to inform future papers.</p>
<p>The second revision of this document (25-176r2) was discussed in plenary at J3 meeting #237 on 2025-11-12. The results of the straw polls in 25-176r2 have been applied to the current revision of this paper, 25-176r3, which passed as amended at J3 meeting #237.</p>
<h2><a class="anchor" id="autotoc_md55"></a>
Straw polls</h2>
<h3><a class="anchor" id="autotoc_md56"></a>
Straw poll 1</h3>
<p>How should fixed source form be handled in forthcoming syntax/edit papers for preprocessing?</p>
<p><b>OPTION A</b>: Fixed source form preprocessing should be fully specified, and support is just as mandatory as free-form preprocessing.</p>
<p><b>OPTION B</b>: Fixed source form preprocessing should have recommendations but be explicitly labeled as optional because of fixed-form obsolescence.</p>
<p><b>OPTION C</b>: Nothing should be specified about preprocessing for fixed source form, which means preprocessing for fixed source form remains entirely processor-dependent (as it is today). The edits should explicitly note that preprocessing of fixed source form is processor-dependent.</p>
<p>The subgroup is unanimously opposed to option A, and recommends option C.</p>
<blockquote class="doxtable">
<p>&zwj;At plenary on 2025-11-12, the straw poll results were:</p><ul>
<li>OPTION A: 4 votes</li>
<li>OPTION B: 5 votes</li>
<li>OPTION C: 9 votes</li>
<li>Undecided: 2 votes </li>
</ul>
</blockquote>
<p>Based on these totals, this revision adopts <b>OPTION C</b>.</p>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] the results of straw poll 1 will inform the content of subsequent papers, not serve to excise content from this paper. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md57"></a>
Straw poll 2</h3>
<p>Should it be mandatory to explicitly continue lines inside the argument list for the invocation of a function-like macro?</p>
<p><b>OPTION R</b>: Explicit Fortran-style continuation is required to continue lines within the argument list of a function-like macro invocation. If a function-like macro invocation begins on one line and the closing ')' needed to close the argument list does not appear on the same line, then Fortran-style continuation syntax must be used to mark the continuation, otherwise the processor may consider this an error.</p>
<p><b>OPTION O</b>: Explicit Fortran-style continuation is permitted, but not required, to continue lines within the argument list of a function-like macro invocation. If a function-like macro invocation begins on one line and the closing ')' needed to close the argument list does not appear on the same line, the processor will continue looking for the closing ')' on subsequent source fragment lines, even without explicit continuation syntax.</p>
<p>In either case, any explicit continuation characters (e.g. a trailing <code>&amp;</code> in free form) are not part of the argument list of a function-like macro.</p>
<p>The subgroup does not have a recommendation and is divided. The subgroup unanimously agrees that either option is preferable to not passing a version of this paper.</p>
<blockquote class="doxtable">
<p>&zwj;At plenary on 2025-11-12, the straw poll results were:</p><ul>
<li>OPTION R: 11 votes</li>
<li>OPTION O: 4 votes</li>
<li>Undecided: 5 votes </li>
</ul>
</blockquote>
<p>Based on these totals, this revision adopts <b>OPTION R</b>.</p>
<h3><a class="anchor" id="autotoc_md58"></a>
Straw poll 2 analysis</h3>
<p>The analysis provided below is intended to help inform the committee regarding the implications of straw poll 2.</p>
<h4><a class="anchor" id="autotoc_md59"></a>
PROS OPTION R:</h4>
<p>||| |:&mdash;|:&mdash;| |RP01|Forces a style which is more aesthetically "Fortranic".| |||</p>
<h4><a class="anchor" id="autotoc_md60"></a>
CONS OPTION R:</h4>
<p>||| |:&mdash;|:&mdash;| |RC01|Mandates more restrictive line continuation syntax.| |RC02|Forcing the programmer to type a continuation does not resolve any ambiguity between two or more correct programs in this context. If the the closing <code>)</code> for the argument list does not appear on the opening line, then it must appear on a subsequent line, otherwise the entire program is an error.| |RC03|This requirement will break current codes that don't use explicit continuations (e.g. due to focusing on a compiler that does not currently require them).| |RC04|In compilers that don't currently recognize explicit continuations in FLM invocations, this syntax generates confusing garbage (e.g. adding the <code>&amp;</code> to the argument), which is a very unfriendly error behavior until those compilers are upgraded to the standard preprocessor.| |RC05|Current implementations may need adjustment to match specified behavior.| |||</p>
<h4><a class="anchor" id="autotoc_md61"></a>
PROS OPTION O:</h4>
<p>||| |:&mdash;|:&mdash;| |OP01|Provides more permissive line continuation syntax.| |OP02|Option O accepts a strictly wider set of current programs than Option R, and hence it reduces breakage of existing codes.| |OP03|Users who are accustomed to typing explicit continuations may still do so.| |OP04|Current codes that are not using explicit continuations (e.g. due to focusing on a compiler that does not currently accept them) will continue to work unchanged.| |||</p>
<h4><a class="anchor" id="autotoc_md62"></a>
CONS OPTION O:</h4>
<p>||| |:&mdash;|:&mdash;| |OC01|Allows omitting the redundant continuation indicator, a style which is less aesthetically "Fortranic".| |OC02|Current implementations may need adjustment to match specified behavior.| |||</p>
<h1><a class="anchor" id="autotoc_md63"></a>
Specifications</h1>
<h2><a class="anchor" id="autotoc_md64"></a>
General</h2>
<p>||| |:&mdash;|:&mdash;| |ge01|Macro identification and expansion is a process that occurs on source fragment lines and comment lines when they are first encountered during preprocessing, and may be recursively repeated as specified in section 4.| |ge03|During expansion, an identifier that is the name of a defined object-like macro (25-142r2 section 3.1) is replaced by the replacement-list of that macro's definition.| |ge05| During expansion, an identifier that is the name of a defined function-like macro (25-142r2 section 3.2) followed by a left parenthesis '(' introduces an invocation of the function-like macro. The arguments of the macro invocation are collected before the macro is expanded (section 2).| |ge07|After expansion has replaced a macro invocation, the resulting tokens are rescanned to find additional macro invocations for expansion (section 4).|</p>
<h2><a class="anchor" id="autotoc_md65"></a>
Function-like macro invocation</h2>
<h3><a class="anchor" id="autotoc_md66"></a>
Function-like macro identification</h3>
<h4><a class="anchor" id="autotoc_md67"></a>
Argument gathering and separation</h4>
<p>This subsection specifies the rules used to gather and separate the arguments for the invocation of a function-like macro.</p>
<p>||| |:&mdash;|:&mdash;| |ag01|During expansion when a function-like macro name is encountered followed by a '(' as the next nonblank character, the processor shall scan ahead, removing comments (section 2.1.4), to identify the full list of macro arguments. This process is known as "argument gathering". The argument list begins after the initial '(' and terminates before the matching closing parenthesis ')', skipping intervening matched pairs of <code>(</code> and <code>)</code> parentheses. The argument list shall terminate before the end of the current file.| |ag03|After argument gathering, argument separation is performed. Commas within the argument list separate individual arguments. However, a comma that appears within a balanced set of parentheses '()', square brackets '[]', or curly braces '{}' does not act as an argument separator. All such bracketing characters within an argument must be balanced and properly nested. Array constructor delimiters '(/ /)' are implicitly handled as a special case of parentheses.| |ag05|During argument gathering, commas and bracketing characters within comments are removed (section 2.1.4) and thus do not affect argument separation.| |ag07|An argument consists of all tokens between the beginning of the argument list and a separating comma, between a pair of separating commas, or between a separating comma and the end of the argument list. Line continuations (sections 2.1.2 and 2.1.3), and comments (section 2.1.4) are removed as part of argument gathering and thus are not part of any arguments themselves.| |ag11|For a macro that is not variadic (section 2.3), the number of arguments in the invocation shall be equal to the number of parameters in the macro definition.| |ag13|For a variadic macro (section 2.3), the number of arguments shall not be less than the number of named parameters in the macro definition, and any arguments supplied beyond the number of named parameters are collectively known as the "variable arguments list" (section 2.3). If the number of arguments is equal to the number of named parameters, then the variable arguments list is empty.| |ag15|An argument is considered empty if it contains no preprocessing tokens. When an empty argument is substituted, it is replaced by a placemarker token (section 3).| |ag17|Preprocessing directives are not recognized as such within the arguments of a function-like macro invocation.| |ag19|Within the arguments of a function-like macro invocation, the token INCLUDE is not treated as introducing an INCLUDE line, even if it resembles one.|</p>
<p><b>EXAMPLE age01</b>:</p>
<p>Given the macro definition: </p><div class="fragment"><div class="line">#define f(a,b,c) a;b;c</div>
</div><!-- fragment --><p> The invocation: </p><div class="fragment"><div class="line">f(1,,3)</div>
</div><!-- fragment --><p> is equivalent to: </p><div class="fragment"><div class="line">1;;3</div>
</div><!-- fragment --><p> The second argument is empty, so 'b' is replaced by a placemarker token, which is then removed (section 4).</p>
<p><b>EXAMPLE age02</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#define ASSIGN(x, y) x = y</span></div>
<div class="line"><span class="preprocessor"></span> </div>
<div class="line">      assign( a(1,2)[3,4], 10 )</div>
</div><!-- fragment --><p> the invocation is equivalent to: </p><div class="fragment"><div class="line">a(1,2)[3,4] = 10</div>
</div><!-- fragment --><p> The commas within the bracketing characters do not act as argument separators, they are instead part of the first argument.</p>
<p><b>EXAMPLE age03</b>:</p>
<p>Given the macro definition: </p><div class="fragment"><div class="line"><span class="preprocessor">#define ACCUM(var, val) \</span></div>
<div class="line"><span class="preprocessor"></span>    var = var+val ;  \</div>
<div class="line">    print *, <span class="stringliteral">&quot;value:&quot;</span>, var</div>
</div><!-- fragment --><p> The invocation: </p><div class="fragment"><div class="line">accum( a(1,2)[3,4], 10 )</div>
</div><!-- fragment --><p> is equivalent to: </p><div class="fragment"><div class="line">a(1,2)[3,4] = a(1,2)[3<span class="comment">,4]+10 ; print *, </span><span class="stringliteral">&quot;value:&quot;</span><span class="comment">, a(1,2)[3,4]</span></div>
</div><!-- fragment --><p><b>EXAMPLE age04</b>:</p>
<p>Given the macro definition: </p><div class="fragment"><div class="line"><span class="comment">#define assign(x, y) x = y</span></div>
</div><!-- fragment --><p> The invocation: </p><div class="fragment"><div class="line">assign<span class="comment">(a(5,6)[7,8], foo{t1, t2}(9, b[10,11]))</span></div>
</div><!-- fragment --><p> is equivalent to: </p><div class="fragment"><div class="line">a<span class="comment">(5,6)[7,8] = foo{t1, t2}(9, b[10,11])</span></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md68"></a>
Line breaks and continuations in macro invocations (free-form)</h4>
<p>This subsection describes the handling of line continuations during argument gathering within function-like macro invocations in free source form.</p>
<p>||| |:&mdash;|:&mdash;| |lb01|An invocation of a function-like macro can be continued across multiple lines. An invocation that begins with an open parenthesis '(' continues until the matching closing parenthesis ')' is found (outside of a comment).| |lb03|Comment lines within the argument list of an invocation of a function-like macro are discarded (section 2.1.4).| |lb05|A newline character appearing within the argument list is treated as a blank character, except where rule lb07 applies.| |lb07|Fortran-style continuation markers are required when the argument list spans multiple source fragment lines. An ampersand '&amp;' which is the last non-whitespace character (after the removal of comments) preceding a newline character is removed, and all subsequent characters up to and including the newline are removed. If the first non-whitespace character on a continuation line is an ampersand '&amp;', all characters up to and including the leading ampersand '&amp;' are removed.| |||</p>
<p><b>EXAMPLE lbe01</b>:</p>
<p>If MAC is a function-like macro which accepts three arguments, then the following lines: </p><div class="fragment"><div class="line">mac<span class="comment">(a,</span></div>
<div class="line"><span class="comment"></span>      b,</div>
<div class="line">      c)</div>
<div class="line">mac(q,r</div>
<div class="line">s,</div>
<div class="line">t)</div>
</div><!-- fragment --><p> have a processor-dependent interpretation.</p>
<p>If MAC is a function-like macro which accepts three arguments, then the following lines: </p><div class="fragment"><div class="line">mac(a, &amp;</div>
<div class="line">      b, &amp;</div>
<div class="line">      &amp; c)</div>
<div class="line">mac(d, &amp;</div>
<div class="line">      e &amp;</div>
<div class="line">      &amp;f, g)</div>
<div class="line">mac(h, &amp;</div>
<div class="line">      i&amp;</div>
<div class="line">      &amp;j, k)</div>
<div class="line">mac(l, m&amp;</div>
<div class="line">      n&amp;</div>
<div class="line">      &amp;o, p)</div>
</div><!-- fragment --><p> are equivalent to: </p><div class="fragment"><div class="line">mac(a,b,c)</div>
<div class="line">mac(d,e f,g)</div>
<div class="line">mac(h,ij,k)</div>
<div class="line">mac(l,m no,p)</div>
</div><!-- fragment --><p> where all line continuations and extraneous blank characters have been removed.</p>
<h4><a class="anchor" id="autotoc_md69"></a>
Line breaks and continuations in macro invocations (fixed-form)</h4>
<blockquote class="doxtable">
<p>&zwj;[!WARNING] J3 recommends against specifying preprocessing for fixed source form. </p>
</blockquote>
<p>This subsection describes the handling of line continuations during argument gathering within function-like macro invocations in fixed source form.</p>
<p>||| |:&mdash;|:&mdash;| |lc01|An invocation of a function-like macro can be continued across multiple lines. An invocation that begins with an open parenthesis '(' continues until the matching closing parenthesis ')' is found (outside of a comment).| |lc03|Comment lines within the argument list of an invocation of a function-like macro are discarded (section 2.1.4).| |lc07|If character position 6 of a source fragment line contains any character other than a blank or zero, then any trailing blank characters of the continued line are removed along with the newline.| |lc09|On a continuation source fragment line inside the argument list for a function-like macro, character positions 1 to 5 shall be blank.| |||</p>
<p><b>EXAMPLE lce01</b>:</p>
<p>If MAC is a function-like macro which accepts three arguments, then the following lines: </p><div class="fragment"><div class="line"><span class="comment">!23456</span></div>
<div class="line">      mac(a,</div>
<div class="line">            b,</div>
<div class="line">            c)</div>
<div class="line">      mac(q,r</div>
<div class="line">      s,</div>
<div class="line">      t)</div>
</div><!-- fragment --><p> have a processor-dependent interpretation.</p>
<p>If MAC is a function-like macro which accepts three arguments, then the following lines: </p><div class="fragment"><div class="line"><span class="comment">!23456</span></div>
<div class="line">      mac(a,</div>
<div class="line">      &amp;    b,</div>
<div class="line">      &amp;    c)</div>
<div class="line">      mac(d,</div>
<div class="line">      &amp;    e</div>
<div class="line">      &amp;    f, g)</div>
<div class="line">      mac(h,</div>
<div class="line">      &amp;    i</div>
<div class="line">      &amp;j, k)</div>
<div class="line">      mac(l, m</div>
<div class="line">      &amp;    n</div>
<div class="line">      &amp;o, p)</div>
</div><!-- fragment --><p> are equivalent to: </p><div class="fragment"><div class="line"><span class="comment">!23456</span></div>
<div class="line">      mac(a,b,c)</div>
<div class="line">      mac(d,e f,g)</div>
<div class="line">      mac(h,ij,k)</div>
<div class="line">      mac(l,m no,p)</div>
</div><!-- fragment --><p> where all line continuations and extraneous blank characters have been removed.</p>
<h4><a class="anchor" id="autotoc_md70"></a>
Comments in macro invocations</h4>
<p>This subsection details how Fortran-style comments and comment lines appearing within the argument list of a function-like macro invocation are removed during argument gathering and do not become part of the arguments.</p>
<p>||| |:&mdash;|:&mdash;| |cm03|A Fortran comment line encountered during argument gathering, including the newline, is removed.| |cm05|During argument gathering, a Fortran-style comment on a source fragment line begins with an exclamation mark '!' and includes all subsequent characters on that line. The entire sequence is removed (not including the newline character).| |cm07|In a source fragment line, the token sequences '/*' and '*/' are not interpreted as bracketing a comment (unlike in directive lines, see 25-142r2 section 2.4). C-style comments are not supported on source fragment lines.| |cm09|In a source fragment line, the '//' token is not interpreted as introducing a comment.| |cm11|The processing specified in this subsection effectively takes place before line continuation processing (sections 2.1.2 and 2.1.3).| |||</p>
<p><b>EXAMPLE cme01</b>:</p>
<p>Given the macro definition: </p><div class="fragment"><div class="line">#define add(a,b) a+b</div>
</div><!-- fragment --><p> The following invocation in free-form source: </p><div class="fragment"><div class="line">add(1, &amp; <span class="comment">! first argument is 1</span></div>
<div class="line">      1)   ! second argument is 2</div>
</div><!-- fragment --><p> is equivalent to: </p><div class="fragment"><div class="line">add(1,2)   ! second argument is 2</div>
</div><!-- fragment --><p> and is equivalent to: </p><div class="fragment"><div class="line">1+2   <span class="comment">! second argument is 2</span></div>
</div><!-- fragment --><p> <b>EXAMPLE cme02</b>: (free-form)</p>
<p>If MAC is a function-like macro which accepts three arguments, then the following free form source lines: </p><div class="fragment"><div class="line">mac<span class="comment">(d, &amp; ! comment 1</span></div>
<div class="line">      e, &amp; <span class="comment">! comment 2</span></div>
<div class="line">            <span class="comment">! comment line</span></div>
<div class="line">      &amp; f)</div>
<div class="line">mac(g, &amp; <span class="comment">!$foo 1</span></div>
<div class="line">      h, &amp; <span class="comment">!$foo 2</span></div>
<div class="line">      i)   <span class="comment">!$foo 3</span></div>
<div class="line">mac(j,k&amp; <span class="comment">! comment 1</span></div>
<div class="line">      &amp;l&amp;  <span class="comment">! comment 2</span></div>
<div class="line">            <span class="comment">! comment line</span></div>
<div class="line">      &amp;m, n)</div>
<div class="line">mac(o,p&amp; <span class="comment">! comment 1</span></div>
<div class="line">      &amp;q &amp; <span class="comment">! comment 2</span></div>
<div class="line">      &amp;r,s)</div>
<div class="line">mac(t,u&amp;<span class="comment">!comment 1</span></div>
<div class="line">      v,&amp;<span class="comment">!comment 2</span></div>
<div class="line">      w)</div>
</div><!-- fragment --><p> are equivalent to: </p><div class="fragment"><div class="line">mac(d,e,f)</div>
<div class="line">mac(g,h,i) <span class="comment">!$foo 3</span></div>
<div class="line">mac(j,klm,n)</div>
<div class="line">mac(o,pq r,s)</div>
<div class="line">mac(t,u v,w)</div>
</div><!-- fragment --><p> where all line continuations and extraneous blank characters have been removed.</p>
<p><b>EXAMPLE cme03</b>: (fixed-form)</p>
<blockquote class="doxtable">
<p>&zwj;[!WARNING] J3 recommends against specifying preprocessing for fixed source form. </p>
</blockquote>
<p>If MAC is a function-like macro which accepts three arguments, then the following fixed form source lines: </p><div class="fragment"><div class="line"><span class="comment">!23456</span></div>
<div class="line">      mac(d, <span class="comment">! comment 1</span></div>
<div class="line">      &amp;    e, <span class="comment">! comment 2</span></div>
<div class="line"><span class="comment">c comment line</span></div>
<div class="line">      &amp;    f)</div>
<div class="line">      mac(g, <span class="comment">!$foo 1</span></div>
<div class="line">      &amp;    h, <span class="comment">!$foo 2</span></div>
<div class="line">      &amp;    i) <span class="comment">!$foo 3</span></div>
<div class="line">      mac(j,k <span class="comment">!comment 1</span></div>
<div class="line">      &amp;l <span class="comment">! comment 2</span></div>
<div class="line">            <span class="comment">! comment line</span></div>
<div class="line">      &amp;m, n)</div>
<div class="line">      mac(o,p <span class="comment">! comment 1</span></div>
<div class="line">      &amp;q<span class="comment">! comment 2</span></div>
<div class="line">      &amp; r,s)</div>
</div><!-- fragment --><p> are equivalent to: </p><div class="fragment"><div class="line"><span class="comment">!23456</span></div>
<div class="line">      mac(d,e,f)</div>
<div class="line">      mac(g,h,i) <span class="comment">!$foo 3</span></div>
<div class="line">      mac(j,klm,n)</div>
<div class="line">      mac(o,pq r,s)</div>
</div><!-- fragment --><p> where all line continuations and extraneous blank characters have been removed.</p>
<h3><a class="anchor" id="autotoc_md71"></a>
Argument substitution and expansion</h3>
<p>After the arguments of a function-like macro have been identified, argument substitution is performed. This section details how argument substitution is performed, which may include macro expansion of the argument tokens as a part of substitution.</p>
<h4><a class="anchor" id="autotoc_md72"></a>
Macro expansion during argument substitution</h4>
<p>||| |:&mdash;|:&mdash;| |me01|For each parameter appearing in the replacement list of a function-like macro that is neither preceded by <code>#</code> (section 2.2.2), nor preceded or followed by <code>##</code> (section 3), nor part of a <code>&lt;va-opt-replacement&gt;</code> (section 2.3.1), the tokens comprising the corresponding argument of an invocation are subjected to complete macro expansion as if they were the only tokens remaining in the file. The result of that expansion is then substituted for the parameter in the replacement list. If the <code>__VA_ARGS__</code> identifier (section 2.3) appears in the replacement-list, it is treated as if it were a parameter and the variable arguments form the tokens that are expanded (as described above) and then used to replace it.| |me05|The entire function-like macro invocation, from the identifier to the closing ')', is replaced by the tokens from the replacement-list after all substitutions as described in this document.| |me07|The resulting tokens are rescanned for the presence of further macro names to be expanded, according to the rules in section 4.| |||</p>
<h4><a class="anchor" id="autotoc_md73"></a>
The Stringizing Operator (<code>#</code>)</h4>
<p>||| |:&mdash;|:&mdash;| |st01|If a parameter in a function-like macro's replacement list is immediately preceded by a '#' token, the '#' and the parameter are replaced by a single character literal containing the preprocessing tokens of the corresponding argument (which are not expanded, see me01).| |st02|(C2023 6.10.5.2-3) Let the "stringizing argument" be the preprocessing token sequence for the corresponding argument with placemarker tokens removed. Each occurrence of white space between the stringizing argument's preprocessing tokens becomes a single space character in the character string literal. White space before the first preprocessing token and after the last preprocessing token composing the stringizing argument is deleted. Otherwise, the original spelling of each preprocessing token in the stringizing argument is retained in the character string literal, except for special handling for producing the spelling of character literals (st03).| |st03|Each double quote character (") within the stringizing argument is replaced by a pair of double quote characters (""). The resulting sequence of characters is then enclosed in double quotes to form the character literal.|
|||

&lt;strong&gt;EXAMPLE ste01&lt;/strong&gt;:

Given the macro definitions:
@icode{fortran} 
#define fox rabbit
#define STR(x) #x
@endicode 
The invocation:
@icode{fortran} 
      STR( The "quick"   brown fox )
@endicode 
is equivalent to:
@icode{fortran} 
      "The ""quick"" brown fox"
@endicode 

@subsubsection autotoc_md74 Variadic Macros

|||
|:&amp;mdash;|:&amp;mdash;|
|vm01|A function-like macro can be defined to accept a variable number of arguments by specifying an ellipsis '...' as its final parameter (25-142r2 section 3.2). Such a macro is a "variadic" macro.|
|vm03|The special identifier &lt;tt&gt;__VA_ARGS__&lt;/tt&gt; may only appear in the replacement list of a variadic macro.|
|vm05|During expansion of a variadic macro, the variable arguments list is merged by inserting commas between the elements of the list. An identifier &lt;tt&gt;__VA_ARGS__&lt;/tt&gt; in the replacement list is treated as a parameter and the merged variable arguments are the corresponding argument which is then substituted according to rule me01. If the variable arguments list is empty or if the substitution of the merged variable arguments results in no tokens, then the &lt;tt&gt;__VA_ARGS__&lt;/tt&gt; identifier in the replacement-list is replaced by a placemarker token (section 3).|
|||

&lt;strong&gt;EXAMPLE vme01&lt;/strong&gt;:

Given the macro definitions:
@icode{fortran} 
#define LOG(p, ...) call log_message(p, __VA_ARGS__)
#define WARN(...) call log_message("WARNING", __VA_ARGS__)
@endicode 
The invocation:
@icode{fortran} 
      LOG("Index out of bounds:", i, j, k )
@endicode 
is equivalent to:
@icode{fortran} 
      call log_message("Index out of bounds:", i, j, k)
@endicode 
The invocation:
@icode{fortran} 
      WARN("Initialization failed")
@endicode 
is equivalent to:
@icode{fortran} 
      call log_message("WARNING", "Initialization failed")
@endicode 
The invocation:
@icode{fortran} 
      LOG("Task complete")
@endicode 
is equivalent to:
@icode{fortran} 
      call log_message("Task complete", )
@endicode 

@paragraph autotoc_md75 &lt;tt&gt;__VA_OPT__&lt;/tt&gt;

Syntax:
@icode 
  &lt;va-opt-replacement&gt; &lt;&lt;is&gt;&gt;
      `__VA_OPT__` ( &lt;va-opt-arg&gt; )
@endicode 

|||
|:&amp;mdash;|:&amp;mdash;|
|vo01|The special identifier &lt;tt&gt;__VA_OPT__&lt;/tt&gt; may only appear in the replacement list of a variadic macro, followed by a parenthesized sequence of preprocessing tokens. The sequence of preprocessing tokens within the parentheses is called the &lt;tt&gt;\&lt;va-opt-arg\&gt;&lt;/tt&gt;. The closing ')' is determined by skipping intervening pairs of matching left and right parentheses in its preprocessing tokens.|
|vo03|A &lt;tt&gt;\&lt;va-opt-arg\&gt;&lt;/tt&gt; shall not contain the identifier &lt;tt&gt;__VA_OPT__&lt;/tt&gt;.|
|vo05|When a variadic function-like macro is being expanded, if the replacement-list contains a &lt;tt&gt;\&lt;va-opt-replacement\&gt;&lt;/tt&gt;, the following two rules apply.|
|vo07|If the variable arguments list is empty (rule ag13) or if the expansion of the merged variable argument list (rule vm05) results in no tokens, then the &lt;tt&gt;\&lt;va-opt-replacement\&gt;&lt;/tt&gt; is replaced by a placemarker token (section 3).|
|vo09|If the expansion of the merged variable argument list (rule vm05) results in a non-empty sequence of tokens, then the &lt;tt&gt;\&lt;va-opt-replacement\&gt;&lt;/tt&gt; is replaced by the expansion of &lt;tt&gt;\&lt;va-opt-arg\&gt;&lt;/tt&gt;. Any occurrences of macro parameters including &lt;tt&gt;__VA_ARGS__&lt;/tt&gt; within the &lt;tt&gt;\&lt;va-opt-arg\&gt;&lt;/tt&gt; are substituted as specified in rule me01 before that expansion is performed.|
|||

&lt;strong&gt;EXAMPLE voe01&lt;/strong&gt;:

Given the macro definitions:
@icode{fortran} 
#define LOG(msg, ...) call log_message(msg __VA_OPT__(, __VA_ARGS__))
#define NOTHING
@endicode 
The invocation:
@icode{fortran} 
      LOG("hello")
@endicode 
is equivalent to:
@icode{fortran} 
      call log_message("hello" )
@endicode 
The invocation:
@icode{fortran} 
      LOG("Answer:", 42)
@endicode 
is equivalent to:
@icode{fortran} 
      call log_message("Answer:" , 42)
@endicode 
The invocation:
@icode{fortran} 
      LOG("nothing:", NOTHING)
@endicode 
is equivalent to
@icode{fortran} 
      call log_message("nothing:" ) </p>
<h2><a class="anchor" id="autotoc_md76"></a>
The Token-Pasting Operator (<code>##</code>)</h2>
<p>||| |:&mdash;|:&mdash;| |tp01|If a '##' operator appears in the replacement list of an object-like or function-like macro, it concatenates the preceding and following preprocessing tokens to form a single new preprocessing token. Any whitespace surrounding the '##' operator is removed. The result of the concatenation must be a valid preprocessing token.| |tp02|Placemarker tokens are handled specially: concatenation of two placemarkers results in a single placemarker token, and concatenation of a placemarker with a non-placemarker token results in the non-placemarker token.| |tp03|If an operand of the '##' operator is a macro parameter, the parameter is replaced by the corresponding argument's preprocessing tokens, and the resulting token adjacent to the '##' operator becomes its operand. The argument tokens are not macro-expanded before this concatenation (see me01).| |tp07|The '##' operator shall not appear at the beginning or end of a replacement list.| |||</p>
<p><b>EXAMPLE tpe01</b>:</p>
<p>Given the macro definition: </p><div class="fragment"><div class="line">#define make_var(<span class="keywordtype">type</span>, index) <span class="keywordtype">type</span> ## var ## index</div>
</div><!-- fragment --><p> The invocation: </p><div class="fragment"><div class="line"><span class="keywordtype">integer</span><span class="comment"> :: MAKE_VAR(</span><span class="keywordtype">real</span><span class="comment">, 1)</span></div>
</div><!-- fragment --><p> is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordtype">integer</span><span class="comment"> :: realvar1</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md77"></a>
Rescanning and Recursion Prevention</h2>
<p>||| |:&mdash;|:&mdash;| |rs01|After a macro invocation is replaced, all placemarker tokens are removed from the replacement. This removal never pastes adjacent tokens together. The resulting sequence of tokens is rescanned, together with the subsequent tokens in the source file, for more macro names to expand.| |rs03|(C2023 6.10.5.4-2) If the name of the macro being replaced is found during this scan of the replacement list (not including the rest of the source file's preprocessing tokens), it is not replaced. Furthermore, if any nested replacements encounter the name of the macro being replaced, it is not replaced. These nonreplaced macro name preprocessing tokens are no longer available for further replacement even if they are later (re)examined in contexts in which that macro name preprocessing token would otherwise have been replaced.| |rs05|The resulting completely macro-replaced preprocessing token sequence is not recognized as a preprocessing directive, even if it resembles one.| |rs07|An INCLUDE line which results from a completely macro-replaced preprocessing token sequence is then processed as described in 25-142r2 section 8 (meaning the INCLUDE line is honored).| |||</p>
<p><b>EXAMPLE rse01</b>:</p>
<p>Given the macro definitions: </p><div class="fragment"><div class="line"><span class="preprocessor">#define A A</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define B C</span></div>
<div class="line"><span class="preprocessor"></span>#define c b</div>
</div><!-- fragment --><p> The invocations: </p><div class="fragment"><div class="line">a</div>
<div class="line">b</div>
</div><!-- fragment --><p> once fully expanded are equivalent to: </p><div class="fragment"><div class="line">a</div>
<div class="line">b</div>
</div><!-- fragment --><p> Here A was expanded once, then expansion stopped due to rule rs03. Similarly, B was expanded once to C, then rescanned and expanded back into B, then expansion stopped due to rule rs03.</p>
<p><b>EXAMPLE rse02</b>:</p>
<p>Given the macro definitions: </p><div class="fragment"><div class="line"><span class="preprocessor">#define X(a) (a, Y(a))</span></div>
<div class="line"><span class="preprocessor"></span>#define y(a) (a, x(a))</div>
</div><!-- fragment --><p> The invocation: </p><div class="fragment"><div class="line">x(1)</div>
</div><!-- fragment --><p> is equivalent to: </p><div class="fragment"><div class="line">(1, (1, x(1)))</div>
</div><!-- fragment --><p> <b>EXAMPLE rse03</b>:</p>
<p>Given the macro definition: </p><div class="fragment"><div class="line">#define id(x) x</div>
</div><!-- fragment --><p> The invocation </p><div class="fragment"><div class="line">id(id(1))</div>
</div><!-- fragment --><p> is equivalent to: </p><div class="fragment"><div class="line">1</div>
</div><!-- fragment --><p> <b>EXAMPLE rse05</b>:</p>
<p>Given the macro definitions: </p><div class="fragment"><div class="line"><span class="preprocessor">#define H I</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define I(x) J(1)+x(2)</span></div>
<div class="line"><span class="preprocessor"></span>#define j h</div>
</div><!-- fragment --><p> The invocations: </p><div class="fragment"><div class="line">h(k)</div>
<div class="line">h(h)</div>
</div><!-- fragment --><p> are equivalent to: </p><div class="fragment"><div class="line">i(1)+k(2)</div>
<div class="line">i(1)+i(2)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md78"></a>
Appendix A: Divergences from C</h2>
<p>In most ways, the FPP specified by this document and 25-142r2 adheres to the existing practice established by the C preprocessor over the past several decades. However FPP semantics also deliberately diverge from the analogous behavior of the C preprocessor as specified in C 2023. This non-normative section enumerates such deliberate differences that were discussed in this document, as a reference for readers to assist in comparisons.</p>
<p>For additional differences not discussed within this document, see the corresponding Appendix in 25-142r2.</p>
<p>Differences include:</p>
<p>||| |:&mdash;|:&mdash;| |dfc40|FPP expands macro invocations inside Fortran comments on Fortran source fragment lines and in Fortran comment lines (rule ge01).| |dfc50|Line continuation semantics within the argument list of function-like macro invocation have been adjusted to allow for Fortran-style line continuation (sections 2.1.2 and 2.1.3).| |dfc60|Fortran-style comments within the argument list of function-like macro invocation are removed during argument gathering (section 2.1.4).| |dfc70|When determining argument boundaries in the invocation of a function-like macro, FPP ignores commas surrounded by matching sets of '[ ]' and '{ }' bracketing characters, in addition to matching sets of '( )' parentheses (rule ag03).| |dfc80|The rules for applying the stringizing operator <code>#</code> have been adjusted to match Fortran character string quoting (rule st03).| ||| </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    &copy; Copyright 2017 - 2024
    <a href="LICENSE.txt" target="_blank">
    <span class="hidden-xs">Distributed under the</span>
    MIT License</a>
  </ul>
</div>
</body>
</html>
