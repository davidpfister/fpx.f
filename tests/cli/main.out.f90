module test_object_type
implicit none
type :: t_object
integer :: i
real :: x
end type
type :: t_other
integer :: i
real :: x
end type
end module
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without
! modification, are permitted provided that the following conditions are
! met:
!
!  Redistributions of source code must retain the above copyright
! notice, this list of conditions and the following disclaimer.
!   Redistributions in binary form must reproduce the above
! copyright notice, this list of conditions and the following disclaimer
! in the documentation and/or other materials provided with the
! distribution.
!   Neither the name of original developer, nor the names of its
! contributors may be used to endorse or promote products derived from
! this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
! "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
! A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
! OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
! SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
program main; use, intrinsic :: iso_fortran_env; implicit none; integer :: nfailures_all = 0; integer :: nsuccess_all = 0; write(output_unit,'("[==========] Running test cases from ", A)', advance='no') "" ; call flush(output_unit);write(output_unit,*) '';
block; integer :: nfailures = 0; integer :: nsuccess = 0; real, allocatable :: tic_case, toc_case; character(:), allocatable :: testcase; testcase = 'string_tests'; write(output_unit,'("[----------] Test ", A)', advance='no') testcase; call flush(output_unit);write(output_unit,*) ''; block
character(*), parameter :: s1 = 'TEST'
character(:), allocatable :: s2
s2 = 'test'
block; character(*), parameter :: testname = "EXPECT_STREQ"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 25 ; call flush(output_unit);write(output_unit,*) ''; if(s1 .eq. 'TEST') then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 25, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 25; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', s1; print*, ' Expected: ', 'TEST'; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 25, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_STRNE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 26 ; call flush(output_unit);write(output_unit,*) ''; if(s1 .ne. s2) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 26, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 26; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', s1; print*, ' Expected: ', s2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 26, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_STRCASEEQ"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 27 ; call flush(output_unit);write(output_unit,*) ''; block; character(len_trim(s1)) :: s1l; character(len_trim(s2)) :: s2l; integer :: i,j; do i = 1, len_trim(s1); j = iachar(s1(i:i)); if (j>= iachar('A') .and. j<=iachar('Z') ) then; s1l(i:i) = achar(iachar(s1(i:i))+32); else; s1l(i:i) = s1(i:i); end if; end do; do i = 1, len_trim(s2); j = iachar(s2(i:i)); if (j>= iachar('A') .and. j<=iachar('Z') ) then; s2l(i:i) = achar(iachar(s2(i:i))+32); else; s2l(i:i) = s2(i:i); end if; end do; if(s1l .eq. s2l) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 27, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 27; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', s1; print*, ' Expected: ', s2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 27, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block; end block;
block; character(*), parameter :: testname = "ASSERT_STREQ"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 29 ; call flush(output_unit);write(output_unit,*) ''; if(s1 .eq. 'TEST') then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 29, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 29; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', s1; print*, ' Expected: ', 'TEST'; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 29, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_STRNE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 30 ; call flush(output_unit);write(output_unit,*) ''; if(s1 .ne. s2) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 30, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 30; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', s1; print*, ' Expected: ', s2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 30, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_STRCASEEQ"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 31 ; call flush(output_unit);write(output_unit,*) ''; block; character(len_trim(s1)) :: s1l; character(len_trim(s2)) :: s2l; integer :: i,j; do i = 1, len_trim(s1); j = iachar(s1(i:i)); if (j>= iachar('A') .and. j<=iachar('Z') ) then; s1l(i:i) = achar(iachar(s1(i:i))+32); else; s1l(i:i) = s1(i:i); end if; end do; do i = 1, len_trim(s2); j = iachar(s2(i:i)); if (j>= iachar('A') .and. j<=iachar('Z') ) then; s2l(i:i) = achar(iachar(s2(i:i))+32); else; s2l(i:i) = s2(i:i); end if; end do; if(s1l .eq. s2l) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 31, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 31; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', s1; print*, ' Expected: ', s2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 31, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;; end block;
call cpu_time(toc_case); write(output_unit,'("[----------] Ran ", I3, " tests from ", A)', advance='no') nsuccess + nfailures, testcase; call flush(output_unit);write(output_unit,*) ''; if(nfailures > 0) then; nfailures_all = nfailures_all + nfailures; write(output_unit,'(A, I3, " tests from ", A, " (", E10.3, " ms total)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', nfailures, testcase, toc_case - tic_case; else; nsuccess_all = nsuccess_all + nsuccess; write(output_unit,'(A, I3, " tests from ", A, " (", E10.3, " ms total)")', advance='no') achar(27)//'[32m'//'[  PASSED  ]'//achar(27)//'[0m ', nsuccess, testcase, toc_case - tic_case; end if; call flush(output_unit);write(output_unit,*) ''; end block; nsuccess = 0; nfailures = 0; end block;
block; integer :: nfailures = 0; integer :: nsuccess = 0; real, allocatable :: tic_case, toc_case; character(:), allocatable :: testcase; testcase = 'logical_tests'; write(output_unit,'("[----------] Test ", A)', advance='no') testcase; call flush(output_unit);write(output_unit,*) ''; block
logical :: true = .true.
logical :: false = .false.
block; character(*), parameter :: testname = "EXPECT_TRUE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 38 ; call flush(output_unit);write(output_unit,*) ''; if(true .eqv. .true.) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 38, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 38; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', true; print*, ' Expected: ', .true.; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 38, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_FALSE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 39 ; call flush(output_unit);write(output_unit,*) ''; if(false .eqv. .false.) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 39, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 39; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', false; print*, ' Expected: ', .false.; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 39, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_TRUE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 40 ; call flush(output_unit);write(output_unit,*) ''; if(.not. false .eqv. .true.) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 40, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 40; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', .not. false; print*, ' Expected: ', .true.; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 40, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_FALSE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 41 ; call flush(output_unit);write(output_unit,*) ''; if(.not. true .eqv. .false.) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 41, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 41; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', .not. true; print*, ' Expected: ', .false.; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 41, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_TRUE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 42 ; call flush(output_unit);write(output_unit,*) ''; if(true .eqv. .true.) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 42, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 42; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', true; print*, ' Expected: ', .true.; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 42, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_FALSE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 43 ; call flush(output_unit);write(output_unit,*) ''; if(false .eqv. .false.) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 43, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 43; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', false; print*, ' Expected: ', .false.; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 43, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_TRUE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 44 ; call flush(output_unit);write(output_unit,*) ''; if(.not. false .eqv. .true.) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 44, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 44; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', .not. false; print*, ' Expected: ', .true.; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 44, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_FALSE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 45 ; call flush(output_unit);write(output_unit,*) ''; if(.not. true .eqv. .false.) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 45, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 45; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', .not. true; print*, ' Expected: ', .false.; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 45, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
call cpu_time(toc_case); write(output_unit,'("[----------] Ran ", I3, " tests from ", A)', advance='no') nsuccess + nfailures, testcase; call flush(output_unit);write(output_unit,*) ''; if(nfailures > 0) then; nfailures_all = nfailures_all + nfailures; write(output_unit,'(A, I3, " tests from ", A, " (", E10.3, " ms total)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', nfailures, testcase, toc_case - tic_case; else; nsuccess_all = nsuccess_all + nsuccess; write(output_unit,'(A, I3, " tests from ", A, " (", E10.3, " ms total)")', advance='no') achar(27)//'[32m'//'[  PASSED  ]'//achar(27)//'[0m ', nsuccess, testcase, toc_case - tic_case; end if; call flush(output_unit);write(output_unit,*) ''; end block; nsuccess = 0; nfailures = 0; end block;
block; integer :: nfailures = 0; integer :: nsuccess = 0; real, allocatable :: tic_case, toc_case; character(:), allocatable :: testcase; testcase = 'equality_tests_for_types'; write(output_unit,'("[----------] Test ", A)', advance='no') testcase; call flush(output_unit);write(output_unit,*) ''; block
use test_object_type
type(t_object), allocatable, target :: obj1
type(t_object), allocatable ::obj2
type(t_other), allocatable :: obj3
type(t_object), pointer :: ptr => null()
obj1 = t_object(1, 0.5)
obj2 = t_object(5, 1.25)
obj3 = t_other(1, 0.5)
block; character(*), parameter :: testname = "EXPECT_BEQ"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 62 ; call flush(output_unit);write(output_unit,*) ''; block ; integer(kind=1), allocatable :: mold(:); logical :: equals_; equals_ = all(transfer(obj1, mold) == transfer(obj3, mold)); if(equals_) then ; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 62, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 62; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', obj1; print*, ' Expected: ', obj3; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 62, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block; end block
block; character(*), parameter :: testname = "ASSERT_BEQ"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 63 ; call flush(output_unit);write(output_unit,*) ''; block ; integer(kind=1), allocatable :: mold(:); logical :: equals_; equals_ = all(transfer(obj1, mold) == transfer(obj3, mold)); if(equals_) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 63, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 63; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', obj1; print*, ' Expected: ', obj3; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 63, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block; end block
block; character(*), parameter :: testname = "EXPECT_BNEQ"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 64 ; call flush(output_unit);write(output_unit,*) ''; block ; integer(kind=1), allocatable :: mold(:); logical :: equals_; equals_ = all(transfer(obj1, mold) == transfer(obj2, mold)); if(.not. equals_) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 64, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 64; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', obj1; print*, ' Expected: ', obj2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 64, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block; end block
block; character(*), parameter :: testname = "ASSERT_BNEQ"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 65 ; call flush(output_unit);write(output_unit,*) ''; block ; integer(kind=1), allocatable :: mold(:); logical :: equals_; equals_ = all(transfer(obj1, mold) == transfer(obj2, mold)); if(.not. equals_) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 65, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 65; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', obj1; print*, ' Expected: ', obj2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 65, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block; end block
block; character(*), parameter :: testname = "EXPECT_NSAME"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 67 ; call flush(output_unit);write(output_unit,*) ''; block ; logical :: equals_; equals_ = same_type_as(obj1, obj3) .and. loc(obj1) == loc(obj3) .and. storage_size(obj1) == storage_size(obj3) ;if(.not. equals_) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 67, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 67; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', obj1; print*, ' Expected: ', obj3; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 67, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block; end block
block; character(*), parameter :: testname = "ASSERT_NSAME"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 68 ; call flush(output_unit);write(output_unit,*) ''; block ; integer(kind=1), allocatable :: mold(:); logical :: equals_; equals_ = same_type_as(obj1, obj3) .and. loc(obj1) == loc(obj3) .and. storage_size(obj1) == storage_size(obj3) ;if(equals_) equals_ = all(transfer(obj1, mold) == transfer(obj3, mold)); if(.not. equals_) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 68, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 68; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', obj1; print*, ' Expected: ', obj3; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 68, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block; end block
obj2%i = 1
obj2%x = 0.5
block; character(*), parameter :: testname = "EXPECT_NSAME"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 73 ; call flush(output_unit);write(output_unit,*) ''; block ; logical :: equals_; equals_ = same_type_as(obj1, obj2) .and. loc(obj1) == loc(obj2) .and. storage_size(obj1) == storage_size(obj2) ;if(.not. equals_) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 73, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 73; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', obj1; print*, ' Expected: ', obj2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 73, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block; end block
block; character(*), parameter :: testname = "ASSERT_NSAME"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 74 ; call flush(output_unit);write(output_unit,*) ''; block ; integer(kind=1), allocatable :: mold(:); logical :: equals_; equals_ = same_type_as(obj1, obj2) .and. loc(obj1) == loc(obj2) .and. storage_size(obj1) == storage_size(obj2) ;if(equals_) equals_ = all(transfer(obj1, mold) == transfer(obj2, mold)); if(.not. equals_) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 74, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 74; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', obj1; print*, ' Expected: ', obj2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 74, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block; end block
ptr => obj1
block; character(*), parameter :: testname = "EXPECT_SAME"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 77 ; call flush(output_unit);write(output_unit,*) ''; block ; logical :: equals_; equals_ = same_type_as(obj1, ptr) .and. loc(obj1) == loc(ptr) .and. storage_size(obj1) == storage_size(ptr) ;if(equals_) then ; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 77, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 77; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', obj1; print*, ' Expected: ', ptr; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 77, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block; end block
block; character(*), parameter :: testname = "ASSERT_SAME"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 78 ; call flush(output_unit);write(output_unit,*) ''; block ; integer(kind=1), allocatable :: mold(:); logical :: equals_; equals_ = same_type_as(obj1, ptr) .and. loc(obj1) == loc(ptr) .and. storage_size(obj1) == storage_size(ptr) ;if(equals_) equals_ = all(transfer(obj1, mold) == transfer(ptr, mold)); if(equals_) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 78, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 78; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', obj1; print*, ' Expected: ', ptr; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 78, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block; end block
nullify(ptr)
call cpu_time(toc_case); write(output_unit,'("[----------] Ran ", I3, " tests from ", A)', advance='no') nsuccess + nfailures, testcase; call flush(output_unit);write(output_unit,*) ''; if(nfailures > 0) then; nfailures_all = nfailures_all + nfailures; write(output_unit,'(A, I3, " tests from ", A, " (", E10.3, " ms total)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', nfailures, testcase, toc_case - tic_case; else; nsuccess_all = nsuccess_all + nsuccess; write(output_unit,'(A, I3, " tests from ", A, " (", E10.3, " ms total)")', advance='no') achar(27)//'[32m'//'[  PASSED  ]'//achar(27)//'[0m ', nsuccess, testcase, toc_case - tic_case; end if; call flush(output_unit);write(output_unit,*) ''; end block; nsuccess = 0; nfailures = 0; end block;
block; integer :: nfailures = 0; integer :: nsuccess = 0; real, allocatable :: tic_case, toc_case; character(:), allocatable :: testcase; testcase = 'inequality_tests'; write(output_unit,'("[----------] Test ", A)', advance='no') testcase; call flush(output_unit);write(output_unit,*) ''; block
double precision, parameter :: r1 = 1.0d0
double precision :: r2 = 1.0d0
double precision :: r3 = 2.0d0
block; character(*), parameter :: testname = "EXPECT_EQ"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 88 ; call flush(output_unit);write(output_unit,*) ''; if(r1 .eq. r2) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 88, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 88; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', r1; print*, ' Expected: ', r2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 88, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_EQ"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 89 ; call flush(output_unit);write(output_unit,*) ''; if(r1 .eq. r2) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 89, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 89; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', r1; print*, ' Expected: ', r2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 89, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_NE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 91 ; call flush(output_unit);write(output_unit,*) ''; if(r1 .ne. r3) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 91, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 91; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', r1; print*, ' Expected: ', r3; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 91, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_NE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 92 ; call flush(output_unit);write(output_unit,*) ''; if(r1 .ne. r3) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 92, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 92; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', r1; print*, ' Expected: ', r3; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 92, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_LE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 94 ; call flush(output_unit);write(output_unit,*) ''; if(r1 .le. r3) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 94, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 94; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', r1; print*, ' Expected: ', r3; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 94, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_LE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 95 ; call flush(output_unit);write(output_unit,*) ''; if(r1 .le. r3) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 95, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 95; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', r1; print*, ' Expected: ', r3; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 95, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_LE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 96 ; call flush(output_unit);write(output_unit,*) ''; if(r1 .le. r2) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 96, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 96; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', r1; print*, ' Expected: ', r2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 96, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_LE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 97 ; call flush(output_unit);write(output_unit,*) ''; if(r1 .le. r2) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 97, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 97; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', r1; print*, ' Expected: ', r2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 97, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_LT"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 99 ; call flush(output_unit);write(output_unit,*) ''; if(r1 .lt. r3) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 99, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 99; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', r1; print*, ' Expected: ', r3; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 99, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_LT"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 100 ; call flush(output_unit);write(output_unit,*) ''; if(r1 .lt. r3) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 100, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 100; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', r1; print*, ' Expected: ', r3; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 100, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_GE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 102 ; call flush(output_unit);write(output_unit,*) ''; if(r3 .ge. r1) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 102, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 102; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', r3; print*, ' Expected: ', r1; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 102, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_GE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 103 ; call flush(output_unit);write(output_unit,*) ''; if(r3 .ge. r1) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 103, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 103; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', r3; print*, ' Expected: ', r1; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 103, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_GE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 104 ; call flush(output_unit);write(output_unit,*) ''; if(r1 .ge. r2) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 104, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 104; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', r1; print*, ' Expected: ', r2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 104, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_GE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 105 ; call flush(output_unit);write(output_unit,*) ''; if(r1 .ge. r2) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 105, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 105; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', r1; print*, ' Expected: ', r2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 105, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_GT"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 107 ; call flush(output_unit);write(output_unit,*) ''; if(r3 .gt. r1) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 107, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 107; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', r3; print*, ' Expected: ', r1; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 107, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_GT"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 108 ; call flush(output_unit);write(output_unit,*) ''; if(r3 .gt. r1) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 108, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 108; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', r3; print*, ' Expected: ', r1; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 108, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
call cpu_time(toc_case); write(output_unit,'("[----------] Ran ", I3, " tests from ", A)', advance='no') nsuccess + nfailures, testcase; call flush(output_unit);write(output_unit,*) ''; if(nfailures > 0) then; nfailures_all = nfailures_all + nfailures; write(output_unit,'(A, I3, " tests from ", A, " (", E10.3, " ms total)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', nfailures, testcase, toc_case - tic_case; else; nsuccess_all = nsuccess_all + nsuccess; write(output_unit,'(A, I3, " tests from ", A, " (", E10.3, " ms total)")', advance='no') achar(27)//'[32m'//'[  PASSED  ]'//achar(27)//'[0m ', nsuccess, testcase, toc_case - tic_case; end if; call flush(output_unit);write(output_unit,*) ''; end block; nsuccess = 0; nfailures = 0; end block;
block; integer :: nfailures = 0; integer :: nsuccess = 0; real, allocatable :: tic_case, toc_case; character(:), allocatable :: testcase; testcase = 'floating_point_tests'; write(output_unit,'("[----------] Test ", A)', advance='no') testcase; call flush(output_unit);write(output_unit,*) ''; block
real, parameter :: e1 = 1.0e0
real :: e2 = 1.0e0
real :: e3 = 2.0e0
double precision, parameter :: d1 = 1.0d0
double precision :: d2 = 1.0d0
double precision :: d3 = 2.0d0
block; character(*), parameter :: testname = "EXPECT_FLOAT_EQ"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 120 ; call flush(output_unit);write(output_unit,*) ''; if(abs(real(e1, real32) - real(e2, real32)) .le. 2.0*spacing(max(abs(real(e1, real32)),abs(real(e2, real32))))) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 120, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 120; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', e1; print*, ' Expected: ', e2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 120, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_FLOAT_EQ"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 121 ; call flush(output_unit);write(output_unit,*) ''; if(abs(real(e1, real32) - real(e2 + 0.5*epsilon(e1), real32)) .le. 2.0*spacing(max(abs(real(e1, real32)),abs(real(e2 + 0.5*epsilon(e1), real32))))) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 121, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 121; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', e1; print*, ' Expected: ', e2 + 0.5*epsilon(e1); write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 121, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_FLOAT_NE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 122 ; call flush(output_unit);write(output_unit,*) ''; if(abs(real(e1, real32) - real(e3, real32)) .gt. 2.0*spacing(max(abs(real(e1, real32)),abs(real(e3, real32))))) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 122, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 122; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', e1; print*, ' Expected: ', e3; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 122, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_FLOAT_EQ"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 123 ; call flush(output_unit);write(output_unit,*) ''; if(abs(real(e1, real32) - real(e2, real32)) .le. 2.0*spacing(max(abs(real(e1, real32)),abs(real(e2, real32))))) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 123, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 123; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', e1; print*, ' Expected: ', e2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 123, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_FLOAT_EQ"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 124 ; call flush(output_unit);write(output_unit,*) ''; if(abs(real(e1, real32) - real(e2 + 0.5*epsilon(e1), real32)) .le. 2.0*spacing(max(abs(real(e1, real32)),abs(real(e2 + 0.5*epsilon(e1), real32))))) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 124, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 124; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', e1; print*, ' Expected: ', e2 + 0.5*epsilon(e1); write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 124, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_FLOAT_NE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 125 ; call flush(output_unit);write(output_unit,*) ''; if(abs(real(e1, real32) - real(e3, real32)) .gt. 2.0*spacing(max(abs(real(e1, real32)),abs(real(e3, real32))))) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 125, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 125; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', e1; print*, ' Expected: ', e3; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 125, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_DOUBLE_EQ"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 127 ; call flush(output_unit);write(output_unit,*) ''; if(abs(real(d1, real64) - real(d2, real64)) .le. 2.0*spacing(max(abs(real(d1, real64)),abs(real(d2, real64))))) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 127, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 127; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', d1; print*, ' Expected: ', d2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 127, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_DOUBLE_NE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 128 ; call flush(output_unit);write(output_unit,*) ''; if(abs(real(d1, real64) - real(d2 + 0.5*epsilon(e1), real64)) .gt. 2.0*spacing(max(abs(real(d1, real64)),abs(real(d2 + 0.5*epsilon(e1), real64))))) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 128, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 128; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', d1; print*, ' Expected: ', d2 + 0.5*epsilon(e1); write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 128, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "EXPECT_DOUBLE_NE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 129 ; call flush(output_unit);write(output_unit,*) ''; if(abs(real(d1, real64) - real(d3, real64)) .gt. 2.0*spacing(max(abs(real(d1, real64)),abs(real(d3, real64))))) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 129, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 129; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', d1; print*, ' Expected: ', d3; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 129, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.false.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_DOUBLE_EQ"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 130 ; call flush(output_unit);write(output_unit,*) ''; if(abs(real(d1, real64) - real(d2, real64)) .le. 2.0*spacing(max(abs(real(d1, real64)),abs(real(d2, real64))))) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 130, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 130; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', d1; print*, ' Expected: ', d2; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 130, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_DOUBLE_NE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 131 ; call flush(output_unit);write(output_unit,*) ''; if(abs(real(d1, real64) - real(d2 + 0.5*epsilon(e1), real64)) .gt. 2.0*spacing(max(abs(real(d1, real64)),abs(real(d2 + 0.5*epsilon(e1), real64))))) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 131, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 131; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', d1; print*, ' Expected: ', d2 + 0.5*epsilon(e1); write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 131, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
block; character(*), parameter :: testname = "ASSERT_DOUBLE_NE"; real :: tic_assert, toc_assert; if(.not. allocated(tic_case)) then ; allocate(tic_case, toc_case); call cpu_time(tic_case); end if; call cpu_time(tic_assert) ; write(output_unit,'("[ RUN      ] ", A, ". ", A, " at line ", I3)', advance='no') testcase, testname, 132 ; call flush(output_unit);write(output_unit,*) ''; if(abs(real(d1, real64) - real(d3, real64)) .gt. 2.0*spacing(max(abs(real(d1, real64)),abs(real(d3, real64))))) then; nsuccess = nsuccess + 1; call cpu_time(toc_assert); write(output_unit,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[32m'//'[       OK ]'//achar(27)//'[0m ', testcase, testname, 132, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; else; nfailures = nfailures + 1; call cpu_time(toc_assert); write(output_unit,'(A, " (", I3, ") : error:")', advance='no') testname, 132; call flush(output_unit);write(output_unit,*) ''; print*, '   Actual: ', d1; print*, ' Expected: ', d3; write(*,'(A, A, ". ", A, " line ", I3, " (", E10.3, " ms)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', testcase, testname, 132, toc_assert - tic_assert;call flush(output_unit);write(output_unit,*) ''; if (.true.) stop 1; end if ; end block;
call cpu_time(toc_case); write(output_unit,'("[----------] Ran ", I3, " tests from ", A)', advance='no') nsuccess + nfailures, testcase; call flush(output_unit);write(output_unit,*) ''; if(nfailures > 0) then; nfailures_all = nfailures_all + nfailures; write(output_unit,'(A, I3, " tests from ", A, " (", E10.3, " ms total)")', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', nfailures, testcase, toc_case - tic_case; else; nsuccess_all = nsuccess_all + nsuccess; write(output_unit,'(A, I3, " tests from ", A, " (", E10.3, " ms total)")', advance='no') achar(27)//'[32m'//'[  PASSED  ]'//achar(27)//'[0m ', nsuccess, testcase, toc_case - tic_case; end if; call flush(output_unit);write(output_unit,*) ''; end block; nsuccess = 0; nfailures = 0; end block;
write(output_unit,'("[==========] Ran ", I3, " tests from ", A)', advance='no') nsuccess_all + nfailures_all, ""; call flush(output_unit);write(output_unit,*) ''; if(nfailures_all > 0) then; write(output_unit,'(A, I3, " tests from ", A)', advance='no') achar(27)//'[31m'//'[  FAILED  ]'//achar(27)//'[0m ', nfailures_all, ""; call flush(output_unit);write(output_unit,*) ''; stop 1; else; write(output_unit,'(A, I3, " tests from ", A)', advance='no') achar(27)//'[32m'//'[  PASSED  ]'//achar(27)//'[0m ', nsuccess_all, ""; call flush(output_unit);write(output_unit,*) ''; end if; end program
